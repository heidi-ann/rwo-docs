<pre><span id="TYPEt"><span class="keyword">type</span> t </span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> pid : <code class="type"><a href="Process.html#TYPEt">t</a> -&gt; <a href="../core/Std.Pid.html#TYPEt">Core.Std.Pid.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> stdin : <code class="type"><a href="Process.html#TYPEt">t</a> -&gt; <a href="Writer.html#TYPEt">Writer.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> stdout : <code class="type"><a href="Process.html#TYPEt">t</a> -&gt; <a href="Reader.html#TYPEt">Reader.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> stderr : <code class="type"><a href="Process.html#TYPEt">t</a> -&gt; <a href="Reader.html#TYPEt">Reader.t</a></code></span></pre>
      
    
<pre><span id="TYPEenv"><span class="keyword">type</span> env </span>= <code class="type">[ `Extend of (string * string) list | `Replace of (string * string) list ]</code> </pre>
      <div class="info"><code class="code">env</code> specifies how to construct the environment that the child process will start
    with.  With <code class="code">`Extend [ x1,v1; x2,v2; ... ]</code>, the child's environment will be the same
    as the parent's, except for <code class="code">xi</code> will have value <code class="code">vi</code>.  With <code class="code">`Replace</code>, the only
    variables in the child's environment will be the <code class="code">xi</code>.  In either case, the child's
    environment is established by first clearing <code class="code">environ</code> and then repeatedly calling
    <code class="code">putenv</code> to establish the desired environment.</div>
    
<pre><span id="TYPEwith_create_args"><span class="keyword">type</span> <code class="type">'a </code>with_create_args </span>= <code class="type">?working_dir:string -&gt;
?env:<a href="Process.html#TYPEenv">env</a> -&gt; prog:string -&gt; args:string list -&gt; unit -&gt; 'a</code> </pre>
      <div class="info"><code class="code">with_create_args</code> specifies the arguments used to create a child process.</div>
    
 
      <pre><span><span class="keyword">val</span> create : <code class="type"><a href="Process.html#TYPEt">t</a> <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a> <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a> <a href="Process.html#TYPEwith_create_args">with_create_args</a></code></span></pre>
      <div class="info"><code class="code">create ~prog ~args ?working_dir ?env ()</code> uses fork+exec to create a child process
    that runs the executable <code class="code">prog</code> with <code class="code">args</code> as arguments.  It creates pipes to
    communicate with the child process's stdin, stdout, and stderr.<br/>    If <code class="code">working_dir</code> is supplied, then the child process will chdir() there before calling
    exec().<br/>    <code class="code">env</code> specifies the environment of the child process.<br/>    <code class="code">create</code> returns <code class="code">Error</code> if it is unable to create the child process.  This can happen
    in any number of situations (unable to fork, unable to create the pipes, unable to
    cd to <code class="code">working_dir</code>, unable to exec, etc.).</div>
    
<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Process.Output.html">Output</a> : <code class="code">sig</code> <a href="Process.Output.html">..</a> <code class="code">end</code></pre><div class="info"><code class="code">wait t</code> closes <code class="code">stdin t</code> and then begins collecting the output produced on <code class="code">t</code>'s
    <code class="code">stdout</code> and <code class="code">stderr</code>, continuing to collect output until <code class="code">t</code> terminates.  As usual,
    other async jobs can run before the deferred returned by <code class="code">wait</code> becomes determined.</div>
	<div class="content" style="display:none">
	<div file="Process.Output.html.contents" class="content_to_load"> </div>
	</div>
  </div>
 
      <pre><span><span class="keyword">val</span> wait : <code class="type"><a href="Process.html#TYPEt">t</a> -&gt; <a href="Process.Output.html#TYPEt">Output.t</a> <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> run : <code class="type">string <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a> <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a> <a href="Process.html#TYPEwith_create_args">with_create_args</a></code></span></pre>
      <div class="info"><code class="code">run</code> <code class="code">create</code>s a process and <code class="code">wait</code>s for it to complete.  If the process exits with
    status zero, then <code class="code">run</code> returns its stdout.  Otherwise, <code class="code">run</code> returns an error
    indicating what went wrong that includes stdout and stderr.  Some care is taken so
    that an error displays nicely as a sexp -- in particular, if the child's output can
    already be parsed as a sexp, then they will display as a sexp (rather than a sexp
    embedded in a string).  Also, if the output isn't a sexp, it will be split on newlines
    into a list of strings, so that it displays on multiple lines rather than a single
    giant line with embedded &quot;\n&quot;'s.</div>
    
 
      <pre><span><span class="keyword">val</span> sexp_of_t : <code class="type"><a href="Process.html#TYPEt">t</a> -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> env_of_sexp : <code class="type"><a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a> -&gt; <a href="Process.html#TYPEenv">env</a></code></span></pre>
      <div class="info"><code class="code">env</code> specifies how to construct the environment that the child process will start
    with.  With <code class="code">`Extend [ x1,v1; x2,v2; ... ]</code>, the child's environment will be the same
    as the parent's, except for <code class="code">xi</code> will have value <code class="code">vi</code>.  With <code class="code">`Replace</code>, the only
    variables in the child's environment will be the <code class="code">xi</code>.  In either case, the child's
    environment is established by first clearing <code class="code">environ</code> and then repeatedly calling
    <code class="code">putenv</code> to establish the desired environment.</div>
    
 
      <pre><span><span class="keyword">val</span> __env_of_sexp__ : <code class="type"><a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a> -&gt; <a href="Process.html#TYPEenv">env</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> sexp_of_env : <code class="type"><a href="Process.html#TYPEenv">env</a> -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a></code></span></pre>
      
    
<br/><code class="code">with_create_args</code> specifies the arguments used to create a child process.<br/>
	  
<br/><code class="code">create ~prog ~args ?working_dir ?env ()</code> uses fork+exec to create a child process
    that runs the executable <code class="code">prog</code> with <code class="code">args</code> as arguments.  It creates pipes to
    communicate with the child process's stdin, stdout, and stderr.<br/>    If <code class="code">working_dir</code> is supplied, then the child process will chdir() there before calling
    exec().<br/>    <code class="code">env</code> specifies the environment of the child process.<br/>    <code class="code">create</code> returns <code class="code">Error</code> if it is unable to create the child process.  This can happen
    in any number of situations (unable to fork, unable to create the pipes, unable to
    cd to <code class="code">working_dir</code>, unable to exec, etc.).<br/>
	  
<br/><code class="code">wait t</code> closes <code class="code">stdin t</code> and then begins collecting the output produced on <code class="code">t</code>'s
    <code class="code">stdout</code> and <code class="code">stderr</code>, continuing to collect output until <code class="code">t</code> terminates.  As usual,
    other async jobs can run before the deferred returned by <code class="code">wait</code> becomes determined.<br/>
	  
<br/><code class="code">run</code> <code class="code">create</code>s a process and <code class="code">wait</code>s for it to complete.  If the process exits with
    status zero, then <code class="code">run</code> returns its stdout.  Otherwise, <code class="code">run</code> returns an error
    indicating what went wrong that includes stdout and stderr.  Some care is taken so
    that an error displays nicely as a sexp -- in particular, if the child's output can
    already be parsed as a sexp, then they will display as a sexp (rather than a sexp
    embedded in a string).  Also, if the output isn't a sexp, it will be split on newlines
    into a list of strings, so that it displays on multiple lines rather than a single
    giant line with embedded &quot;\n&quot;'s.<br/>
	  

<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Thread_pool.Priority.html">Priority</a> : module type of <a href="../core/Std.Linux_ext.Priority.html">Core.Std.Linux_ext.Priority</a> with type t = <a href="../core/Std.Linux_ext.Priority.html#TYPEt">Core.Std.Linux_ext.Priority.t</a></pre>
	<div class="content" style="display:none">
	<div file="Thread_pool.Priority.html.contents" class="content_to_load"> </div>
	</div>
  </div>
<pre><span id="TYPEt"><span class="keyword">type</span> t </span></pre>
      
    
<div class="expanding_content">
	<button onclick="expand_content(this)">-</button>
	<pre><span class="keyword">include</span> <code class="code"><a href="../core/Std.Invariant.S.html">Core.Std.Invariant.S</a></code> with type t = <a href="Thread_pool.html#TYPEt">t</a></pre>
	<div class="content">
	<div file="../core/Std.Invariant.S.html.contents" class="content_to_load"> </div>
	</div>
  </div>
 
      <pre><span><span class="keyword">val</span> create : <code class="type">max_num_threads:int -&gt; <a href="Thread_pool.html#TYPEt">t</a> <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a></code></span></pre>
      <div class="info"><code class="code">create ~max_num_threads</code> returns a new thread pool.  It is an error if
    <code class="code">max_num_threads &lt; 1</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> finished_with : <code class="type"><a href="Thread_pool.html#TYPEt">t</a> -&gt; unit</code></span></pre>
      <div class="info"><code class="code">finished_with t</code> makes it an error to subsequently call <code class="code">add_work* t</code> or
    <code class="code">create_helper_thread t</code>.  And, once all current work in <code class="code">t</code> is finished, destroys all
    the threads in <code class="code">t</code>.  It is OK to call <code class="code">finished_with</code> multiple times on the same <code class="code">t</code>;
    subsequent calls will have no effect.</div>
    
 
      <pre><span><span class="keyword">val</span> max_num_threads : <code class="type"><a href="Thread_pool.html#TYPEt">t</a> -&gt; int</code></span></pre>
      <div class="info"><code class="code">max_num_threads t</code> returns the maximum number of threads that <code class="code">t</code> is allowed to
    create.</div>
    
 
      <pre><span><span class="keyword">val</span> num_threads : <code class="type"><a href="Thread_pool.html#TYPEt">t</a> -&gt; int</code></span></pre>
      <div class="info"><code class="code">num_threads t</code> returns the number of threads that the pool <code class="code">t</code> has created.</div>
    
 
      <pre><span><span class="keyword">val</span> default_priority : <code class="type"><a href="Thread_pool.html#TYPEt">t</a> -&gt; <a href="Thread_pool.Priority.html#TYPEt">Priority.t</a></code></span></pre>
      <div class="info"><code class="code">default_priority t</code> returns the priority that will be used for work performed by
    <code class="code">t</code>, unless that work is added with an overriding priority.</div>
    
 
      <pre><span><span class="keyword">val</span> add_work : <code class="type">?priority:<a href="Thread_pool.Priority.html#TYPEt">Priority.t</a> -&gt;
?name:string -&gt; <a href="Thread_pool.html#TYPEt">t</a> -&gt; (unit -&gt; unit) -&gt; unit <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a></code></span></pre>
      <div class="info"><code class="code">add_work ?priority ?name t f</code> enqueues <code class="code">f</code> to be done by some thread in the pool.<br/>    Exceptions raised by <code class="code">f</code> are silently ignored.<br/>    While the work is run, the name of the thread running the work will be set (via
    <code class="code">Linux_ext.pr_set_name</code>) to <code class="code">name</code> and the priority of the thread will be set
    to <code class="code">priority</code>.<br/>    It is an error to call <code class="code">add_work t</code> after <code class="code">finished_with t</code>.</div>
    
<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Thread_pool.Helper_thread.html">Helper_thread</a> : <code class="code">sig</code> <a href="Thread_pool.Helper_thread.html">..</a> <code class="code">end</code></pre>
	<div class="content" style="display:none">
	<div file="Thread_pool.Helper_thread.html.contents" class="content_to_load"> </div>
	</div>
  </div>
 
      <pre><span><span class="keyword">val</span> create_helper_thread : <code class="type">?priority:<a href="Thread_pool.Priority.html#TYPEt">Priority.t</a> -&gt;
?name:string -&gt; <a href="Thread_pool.html#TYPEt">t</a> -&gt; <a href="Thread_pool.Helper_thread.html#TYPEt">Helper_thread.t</a> <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a></code></span></pre>
      <div class="info"><code class="code">create_helper_thread ?priority ?name t</code> creates a new helper thread.<br/>    The thread pool does not internally refer to the <code class="code">Helper_thread.t</code> it returns.  So, it
    is OK for client code to use a finalizer to detect it becoming unused.<br/>    It is an error if no threads are available.  It is an error to call
    <code class="code">create_helper_thread t</code> after <code class="code">finished_with t</code>.<br/>    When the helper thread runs work, it will be at the helper thread's name and priority,
    except for work that is added with an overriding priority or name.</div>
    
 
      <pre><span><span class="keyword">val</span> add_work_for_helper_thread : <code class="type">?priority:<a href="Thread_pool.Priority.html#TYPEt">Priority.t</a> -&gt;
?name:string -&gt;
<a href="Thread_pool.html#TYPEt">t</a> -&gt; <a href="Thread_pool.Helper_thread.html#TYPEt">Helper_thread.t</a> -&gt; (unit -&gt; unit) -&gt; unit <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a></code></span></pre>
      <div class="info"><code class="code">add_work_for_helper_thread ?priority ?name t helper_thread f</code> enqueues <code class="code">f</code> on
    <code class="code">helper_thread</code>'s work queue.<br/>    Exceptions raised by <code class="code">f</code> are silently ignored.<br/>    It is an error to call <code class="code">add_work_for_helper_thread t</code> after
    <code class="code">finished_with_helper_thread t</code>.<br/>    When the helper thread runs <code class="code">f</code>, it will be at the helper thread's name and priority,
    unless overriden by <code class="code">name</code> or <code class="code">priority</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> finished_with_helper_thread : <code class="type"><a href="Thread_pool.html#TYPEt">t</a> -&gt; <a href="Thread_pool.Helper_thread.html#TYPEt">Helper_thread.t</a> -&gt; unit</code></span></pre>
      <div class="info"><code class="code">finished_with_helper_thread t helper_thread</code> informs thread pool <code class="code">t</code> that no future
    work will be added for <code class="code">helper_thread</code>, and makes it an error to in the future add
    work for <code class="code">helper_thread</code>.  Furthermore, once <code class="code">helper_thread</code> finishes with its last
    piece of work, it will revert to a general thread-pool thread.  It is OK to call
    <code class="code">finished_with_helper_thread</code> multiple times on the same <code class="code">helper_thread</code>; subsequent
    calls will have no effect.</div>
    
 
      <pre><span><span class="keyword">val</span> sexp_of_t : <code class="type"><a href="Thread_pool.html#TYPEt">t</a> -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a></code></span></pre>
      
    
<br/><code class="code">create ~max_num_threads</code> returns a new thread pool.  It is an error if
    <code class="code">max_num_threads &lt; 1</code>.<br/>
	  
<br/><code class="code">finished_with t</code> makes it an error to subsequently call <code class="code">add_work* t</code> or
    <code class="code">create_helper_thread t</code>.  And, once all current work in <code class="code">t</code> is finished, destroys all
    the threads in <code class="code">t</code>.  It is OK to call <code class="code">finished_with</code> multiple times on the same <code class="code">t</code>;
    subsequent calls will have no effect.<br/>
	  
<br/><code class="code">max_num_threads t</code> returns the maximum number of threads that <code class="code">t</code> is allowed to
    create.<br/>
	  
<br/><code class="code">num_threads t</code> returns the number of threads that the pool <code class="code">t</code> has created.<br/>
	  
<br/><code class="code">default_priority t</code> returns the priority that will be used for work performed by
    <code class="code">t</code>, unless that work is added with an overriding priority.<br/>
	  
<br/><code class="code">add_work ?priority ?name t f</code> enqueues <code class="code">f</code> to be done by some thread in the pool.<br/>    Exceptions raised by <code class="code">f</code> are silently ignored.<br/>    While the work is run, the name of the thread running the work will be set (via
    <code class="code">Linux_ext.pr_set_name</code>) to <code class="code">name</code> and the priority of the thread will be set
    to <code class="code">priority</code>.<br/>    It is an error to call <code class="code">add_work t</code> after <code class="code">finished_with t</code>.<br/>
	  
<br/>A helper thread is a thread with its own dedicated work queue.  Work added for the
      helper thread is guaranteed to be run by that thread.  The helper thread only runs
      work explicitly supplied to it.<br/>
	  
<br/><code class="code">default_name t</code> returns the name that will be used for work performed by <code class="code">t</code>,
      unless that work is added with an overriding name<br/>
	  
<br/><code class="code">default_priority t</code> returns the priority that will be used for work performed by
      <code class="code">t</code>, unless that work is added with an overriding priority.<br/>
	  
<br/><code class="code">create_helper_thread ?priority ?name t</code> creates a new helper thread.<br/>    The thread pool does not internally refer to the <code class="code">Helper_thread.t</code> it returns.  So, it
    is OK for client code to use a finalizer to detect it becoming unused.<br/>    It is an error if no threads are available.  It is an error to call
    <code class="code">create_helper_thread t</code> after <code class="code">finished_with t</code>.<br/>    When the helper thread runs work, it will be at the helper thread's name and priority,
    except for work that is added with an overriding priority or name.<br/>
	  
<br/><code class="code">add_work_for_helper_thread ?priority ?name t helper_thread f</code> enqueues <code class="code">f</code> on
    <code class="code">helper_thread</code>'s work queue.<br/>    Exceptions raised by <code class="code">f</code> are silently ignored.<br/>    It is an error to call <code class="code">add_work_for_helper_thread t</code> after
    <code class="code">finished_with_helper_thread t</code>.<br/>    When the helper thread runs <code class="code">f</code>, it will be at the helper thread's name and priority,
    unless overriden by <code class="code">name</code> or <code class="code">priority</code>.<br/>
	  
<br/><code class="code">finished_with_helper_thread t helper_thread</code> informs thread pool <code class="code">t</code> that no future
    work will be added for <code class="code">helper_thread</code>, and makes it an error to in the future add
    work for <code class="code">helper_thread</code>.  Furthermore, once <code class="code">helper_thread</code> finishes with its last
    piece of work, it will revert to a general thread-pool thread.  It is OK to call
    <code class="code">finished_with_helper_thread</code> multiple times on the same <code class="code">helper_thread</code>; subsequent
    calls will have no effect.<br/>
	  

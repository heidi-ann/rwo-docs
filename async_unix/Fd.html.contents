<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Fd.Kind.html">Kind</a> : <code class="code">sig</code> <a href="Fd.Kind.html">..</a> <code class="code">end</code></pre>
	<div class="content" style="display:none">
	<div file="Fd.Kind.html.contents" class="content_to_load"> </div>
	</div>
  </div>
<pre><span id="TYPEt"><span class="keyword">type</span> t </span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> info : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; <a href="../core/Std.Info.html#TYPEt">Core.Std.Info.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> to_string : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; string</code></span></pre>
      <div class="info"><code class="code">to_string t</code> returns a pretty sexp of the representation of <code class="code">t</code> </div>
    
 
      <pre><span><span class="keyword">val</span> create : <code class="type"><a href="Fd.Kind.html#TYPEt">Kind.t</a> -&gt; <a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; <a href="../core/Std.Info.html#TYPEt">Core.Std.Info.t</a> -&gt; <a href="Fd.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">create kind file_descr</code> creates a new <code class="code">t</code> of the underlying kind and file
    descriptor.<br/>    We thought about using <code class="code">fstat()</code> rather than requiring the user to supply the kind.
    But <code class="code">fstat</code> can block, which would require putting this in a thread, which has some
    consequences, and it isn't clear that it gets us that much.  Also, <code class="code">create</code> is mostly
    used within the Async implementation -- clients shouldn't need it unless they are
    mixing Async and non-Async code.</div>
    
 
      <pre><span><span class="keyword">val</span> kind : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; <a href="Fd.Kind.html#TYPEt">Kind.t</a></code></span></pre>
      <div class="info"><code class="code">kind t</code> returns the kind of file descriptor that <code class="code">t</code> is.</div>
    
 
      <pre><span><span class="keyword">val</span> supports_nonblock : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      <div class="info"><code class="code">supports_nonblock t</code> returns true if <code class="code">t</code> supports nonblocking system calls.</div>
    
 
      <pre><span><span class="keyword">val</span> close : <code class="type">?should_close_file_descriptor:bool -&gt; <a href="Fd.html#TYPEt">t</a> -&gt; unit <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">close t</code> prevents further use of <code class="code">t</code>, and closes the underlying file descriptor once
    all the current uses are finished.  The result of <code class="code">close</code> becomes determined once the
    underlying file descriptor has been closed, i.e. once the <code class="code">close()</code> system call
    returns.  It is ok to call <code class="code">close</code> multiple times on the same <code class="code">t</code>; calls subsequent to
    the initial call will have no effect, but will return the same deferred as the
    original call.<br/>    In some situations, one may need to cause async to release an fd that it is managing
    without closing the underlying file descriptor.  In that case, one should supply
    <code class="code">~should_close_file_descriptor:false</code>, which will skip the underlying <code class="code">close()</code> system
    call.<br/>    <code class="code">close_finished t</code> becomes determined after the <code class="code">close()</code> system call on <code class="code">t</code>'s
    underlying file descriptor returns.  <code class="code">close_finished</code> differs from <code class="code">close</code> in that it
    does not have the side effect of initiating a close.<br/>    <code class="code">is_closed t</code> returns <code class="code">true</code> iff <code class="code">close t</code> has been called.</div>
    
 
      <pre><span><span class="keyword">val</span> close_finished : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; unit <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> is_closed : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> with_close : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; f:(<a href="Fd.html#TYPEt">t</a> -&gt; 'a <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a>) -&gt; 'a <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">with_close t f</code> applies <code class="code">f</code> to <code class="code">t</code>, returns the result of <code class="code">f</code>, and closes <code class="code">t</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> is_open : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      <div class="info"><code class="code">is_open t</code> is <code class="code">not (is_closed t</code>)</div>
    
 
      <pre><span><span class="keyword">val</span> stdin : <code class="type">unit -&gt; <a href="Fd.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">stdin</code>, <code class="code">stdout</code>, and <code class="code">stderr</code> are wrappers around the standard Unix file
    descriptors.</div>
    
 
      <pre><span><span class="keyword">val</span> stdout : <code class="type">unit -&gt; <a href="Fd.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> stderr : <code class="type">unit -&gt; <a href="Fd.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> with_file_descr : <code class="type">?nonblocking:bool -&gt;
<a href="Fd.html#TYPEt">t</a> -&gt;
(<a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; 'a) -&gt;
[ `Already_closed | `Error of exn | `Ok of 'a ]</code></span></pre>
      <div class="info"><code class="code">with_file_descr t f</code> runs <code class="code">f</code> on the file descriptor underlying <code class="code">t</code>, if <code class="code">is_open t</code>,
    and returns <code class="code">`Ok</code> or <code class="code">`Error</code> according to <code class="code">f</code>.  If <code class="code">is_closed t</code>, then it does not
    call <code class="code">f</code> and returns <code class="code">`Already_closed</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> with_file_descr_exn : <code class="type">?nonblocking:bool -&gt; <a href="Fd.html#TYPEt">t</a> -&gt; (<a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; 'a) -&gt; 'a</code></span></pre>
      <div class="info"><code class="code">with_file_descr_exn</code> is like <code class="code">with_file_descr</code> except that it raises rather than
    return <code class="code">`Already_closed</code> or <code class="code">`Error</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> with_file_descr_deferred : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt;
(<a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; 'a <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a>) -&gt;
[ `Already_closed | `Error of exn | `Ok of 'a ] <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">with_file_descr_deferred t f</code> runs <code class="code">f</code> on the file descriptor underlying <code class="code">t</code>, if
    <code class="code">is_open t</code>, and returns <code class="code">`Ok</code> or <code class="code">`Error</code> according to <code class="code">f</code>.  If <code class="code">is_closed t</code>, then
    it does not call <code class="code">f</code> and returns <code class="code">`Already_closed</code>.  It ensures that the file
    descriptor underlying <code class="code">t</code> is not closed until the result of <code class="code">f</code> becomes determined (or
    <code class="code">f</code> raises).</div>
    
 
      <pre><span><span class="keyword">val</span> ready_to_interruptible : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt;
[ `Read | `Write ] -&gt;
interrupt:unit <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a> -&gt;
[ `Bad_fd | `Closed | `Interrupted | `Ready ] <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">ready_to_interruptible t read_write ~interrupt</code> returns a deferred that will become
    determined when the file descriptor underlying <code class="code">t</code> can be read from or written to
    without blocking, or when <code class="code">interrupt</code> becomes determined.</div>
    
 
      <pre><span><span class="keyword">val</span> ready_to : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; [ `Read | `Write ] -&gt; [ `Bad_fd | `Closed | `Ready ] <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">ready_to t read_write</code> is like <code class="code">ready_to_interruptible</code>, but without the possibility
    of interruption.</div>
    
 
      <pre><span><span class="keyword">val</span> syscall : <code class="type">?nonblocking:bool -&gt;
<a href="Fd.html#TYPEt">t</a> -&gt;
(<a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; 'a) -&gt;
[ `Already_closed | `Error of exn | `Ok of 'a ]</code></span></pre>
      <div class="info"><code class="code">syscall t f</code> runs <code class="code">Async_unix.syscall</code> with <code class="code">f</code> on the file descriptor underlying
    <code class="code">t</code>, if <code class="code">is_open t</code>, and returns <code class="code">`Ok</code> or <code class="code">`Error</code> according to <code class="code">f</code>.  If
    <code class="code">is_closed t</code>, it does not call <code class="code">f</code> and returns <code class="code">`Already_closed</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> syscall_exn : <code class="type">?nonblocking:bool -&gt; <a href="Fd.html#TYPEt">t</a> -&gt; (<a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; 'a) -&gt; 'a</code></span></pre>
      <div class="info"><code class="code">syscall_exn t f</code> is like <code class="code">syscall</code>, except it raises rather than return
    <code class="code">`Already_closed</code> or <code class="code">`Error</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> syscall_in_thread : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt;
name:string -&gt;
(<a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; 'a) -&gt;
[ `Already_closed | `Error of exn | `Ok of 'a ] <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">syscall_in_thread t f</code> runs <code class="code">In_thread.syscall</code> with <code class="code">f</code> on the file descriptor
    underlying <code class="code">t</code>, if <code class="code">is_open t</code>, and returns a deferred that becomes determined with
    <code class="code">`Ok</code> or <code class="code">`Error</code> when the system call completes.  If <code class="code">is_closed t</code>, it does not call
    <code class="code">f</code> and returns <code class="code">`Already_closed</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> syscall_in_thread_exn : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt;
name:string -&gt; (<a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a> -&gt; 'a) -&gt; 'a <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">syscall_in_thread_exn</code> is like <code class="code">syscall_in_thread</code>, except it raises rather than
    return <code class="code">`Already_closed</code> or <code class="code">`Error</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> of_in_channel : <code class="type"><a href="../core/Std.In_channel.html#TYPEt">Core.Std.In_channel.t</a> -&gt; <a href="Fd.Kind.html#TYPEt">Kind.t</a> -&gt; <a href="Fd.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">of_in_channel</code> and <code class="code">of_out_channel</code> create an fd from their underlying file
    descriptor.</div>
    
 
      <pre><span><span class="keyword">val</span> of_out_channel : <code class="type"><a href="../core/Std.Out_channel.html#TYPEt">Core.Std.Out_channel.t</a> -&gt; <a href="Fd.Kind.html#TYPEt">Kind.t</a> -&gt; <a href="Fd.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> of_in_channel_auto : <code class="type"><a href="../core/Std.In_channel.html#TYPEt">Core.Std.In_channel.t</a> -&gt; <a href="Fd.html#TYPEt">t</a> <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">of_in_channel_auto ic</code> is just like of_in_channel, but uses <code class="code">fstat</code> to determine the
    kind.  It makes some assumptions about sockets, specifically it assumes that a socket
    is either listening, or connected to something (and it uses getsockopt to find out
    which).  Don't pass an in_channel containing an unconnected non-listening socket.</div>
    
 
      <pre><span><span class="keyword">val</span> of_out_channel_auto : <code class="type"><a href="../core/Std.Out_channel.html#TYPEt">Core.Std.Out_channel.t</a> -&gt; <a href="Fd.html#TYPEt">t</a> <a href="Import.Deferred.html#TYPEt">Import.Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">of_out_channel_auto ic</code> is just like of_out_channel, but uses <code class="code">fstat</code> to determine
    the kind.  It makes some assumptions about sockets, specifically it assumes that a
    socket is either listening, or connected to something (and it uses getsockopt to find
    out which).  Don't pass an in_channel containing an unconnected non listening
    socket.</div>
    
 
      <pre><span><span class="keyword">val</span> file_descr_exn : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; <a href="../core/Std.Unix.File_descr.html#TYPEt">Core.Std.Unix.File_descr.t</a></code></span></pre>
      <div class="info"><code class="code">file_descr_exn t</code> returns the file descriptor underlying <code class="code">t</code>, unless <code class="code">is_closed t</code>,
    in which case it raises.  One must be very careful when using this function, and
    should try not to, since any uses of the resulting file descriptor are unknown to
    the <code class="code">Fd</code> module, and hence can violate the guarantee it is trying to enforce.</div>
    
 
      <pre><span><span class="keyword">val</span> to_int_exn : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; int</code></span></pre>
      <div class="info"><code class="code">to_int_exn t</code> returns the the underlying file descriptor as an int.  It has the same
    caveats as <code class="code">file_descr_exn</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> replace : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; <a href="Fd.Kind.html#TYPEt">Kind.t</a> -&gt; <a href="../core/Std.Info.html#TYPEt">Core.Std.Info.t</a> -&gt; unit</code></span></pre>
      <div class="info"><code class="code">replace t kind</code> is for internal use only, by <code class="code">Unix_syscalls</code>.  It is used when one
    wants to reuse a file descriptor in an fd with a new kind.</div>
    
 
      <pre><span><span class="keyword">val</span> sexp_of_t : <code class="type"><a href="Fd.html#TYPEt">t</a> -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a></code></span></pre>
      
    
<br/><code class="code">to_string t</code> returns a pretty sexp of the representation of <code class="code">t</code> <br/>
	  
<br/><code class="code">create kind file_descr</code> creates a new <code class="code">t</code> of the underlying kind and file
    descriptor.<br/>    We thought about using <code class="code">fstat()</code> rather than requiring the user to supply the kind.
    But <code class="code">fstat</code> can block, which would require putting this in a thread, which has some
    consequences, and it isn't clear that it gets us that much.  Also, <code class="code">create</code> is mostly
    used within the Async implementation -- clients shouldn't need it unless they are
    mixing Async and non-Async code.<br/>
	  
<br/><code class="code">kind t</code> returns the kind of file descriptor that <code class="code">t</code> is.<br/>
	  
<br/><code class="code">supports_nonblock t</code> returns true if <code class="code">t</code> supports nonblocking system calls.<br/>
	  
<br/><code class="code">close t</code> prevents further use of <code class="code">t</code>, and closes the underlying file descriptor once
    all the current uses are finished.  The result of <code class="code">close</code> becomes determined once the
    underlying file descriptor has been closed, i.e. once the <code class="code">close()</code> system call
    returns.  It is ok to call <code class="code">close</code> multiple times on the same <code class="code">t</code>; calls subsequent to
    the initial call will have no effect, but will return the same deferred as the
    original call.<br/>    In some situations, one may need to cause async to release an fd that it is managing
    without closing the underlying file descriptor.  In that case, one should supply
    <code class="code">~should_close_file_descriptor:false</code>, which will skip the underlying <code class="code">close()</code> system
    call.<br/>    <code class="code">close_finished t</code> becomes determined after the <code class="code">close()</code> system call on <code class="code">t</code>'s
    underlying file descriptor returns.  <code class="code">close_finished</code> differs from <code class="code">close</code> in that it
    does not have the side effect of initiating a close.<br/>    <code class="code">is_closed t</code> returns <code class="code">true</code> iff <code class="code">close t</code> has been called.<br/>
	  
<br/><code class="code">with_close t f</code> applies <code class="code">f</code> to <code class="code">t</code>, returns the result of <code class="code">f</code>, and closes <code class="code">t</code>.<br/>
	  
<br/><code class="code">is_open t</code> is <code class="code">not (is_closed t</code>)<br/>
	  
<br/><code class="code">stdin</code>, <code class="code">stdout</code>, and <code class="code">stderr</code> are wrappers around the standard Unix file
    descriptors.<br/>
	  
<br/><code class="code">with_file_descr t f</code> runs <code class="code">f</code> on the file descriptor underlying <code class="code">t</code>, if <code class="code">is_open t</code>,
    and returns <code class="code">`Ok</code> or <code class="code">`Error</code> according to <code class="code">f</code>.  If <code class="code">is_closed t</code>, then it does not
    call <code class="code">f</code> and returns <code class="code">`Already_closed</code>.<br/>
	  
<br/><code class="code">with_file_descr_exn</code> is like <code class="code">with_file_descr</code> except that it raises rather than
    return <code class="code">`Already_closed</code> or <code class="code">`Error</code>.<br/>
	  
<br/><code class="code">with_file_descr_deferred t f</code> runs <code class="code">f</code> on the file descriptor underlying <code class="code">t</code>, if
    <code class="code">is_open t</code>, and returns <code class="code">`Ok</code> or <code class="code">`Error</code> according to <code class="code">f</code>.  If <code class="code">is_closed t</code>, then
    it does not call <code class="code">f</code> and returns <code class="code">`Already_closed</code>.  It ensures that the file
    descriptor underlying <code class="code">t</code> is not closed until the result of <code class="code">f</code> becomes determined (or
    <code class="code">f</code> raises).<br/>
	  
<br/><code class="code">ready_to_interruptible t read_write ~interrupt</code> returns a deferred that will become
    determined when the file descriptor underlying <code class="code">t</code> can be read from or written to
    without blocking, or when <code class="code">interrupt</code> becomes determined.<br/>
	  
<br/><code class="code">ready_to t read_write</code> is like <code class="code">ready_to_interruptible</code>, but without the possibility
    of interruption.<br/>
	  
<br/><code class="code">syscall t f</code> runs <code class="code">Async_unix.syscall</code> with <code class="code">f</code> on the file descriptor underlying
    <code class="code">t</code>, if <code class="code">is_open t</code>, and returns <code class="code">`Ok</code> or <code class="code">`Error</code> according to <code class="code">f</code>.  If
    <code class="code">is_closed t</code>, it does not call <code class="code">f</code> and returns <code class="code">`Already_closed</code>.<br/>
	  
<br/><code class="code">syscall_exn t f</code> is like <code class="code">syscall</code>, except it raises rather than return
    <code class="code">`Already_closed</code> or <code class="code">`Error</code>.<br/>
	  
<br/><code class="code">syscall_in_thread t f</code> runs <code class="code">In_thread.syscall</code> with <code class="code">f</code> on the file descriptor
    underlying <code class="code">t</code>, if <code class="code">is_open t</code>, and returns a deferred that becomes determined with
    <code class="code">`Ok</code> or <code class="code">`Error</code> when the system call completes.  If <code class="code">is_closed t</code>, it does not call
    <code class="code">f</code> and returns <code class="code">`Already_closed</code>.<br/>
	  
<br/><code class="code">syscall_in_thread_exn</code> is like <code class="code">syscall_in_thread</code>, except it raises rather than
    return <code class="code">`Already_closed</code> or <code class="code">`Error</code>.<br/>
	  
<br/><code class="code">of_in_channel</code> and <code class="code">of_out_channel</code> create an fd from their underlying file
    descriptor.<br/>
	  
<br/><code class="code">of_in_channel_auto ic</code> is just like of_in_channel, but uses <code class="code">fstat</code> to determine the
    kind.  It makes some assumptions about sockets, specifically it assumes that a socket
    is either listening, or connected to something (and it uses getsockopt to find out
    which).  Don't pass an in_channel containing an unconnected non-listening socket.<br/>
	  
<br/><code class="code">of_out_channel_auto ic</code> is just like of_out_channel, but uses <code class="code">fstat</code> to determine
    the kind.  It makes some assumptions about sockets, specifically it assumes that a
    socket is either listening, or connected to something (and it uses getsockopt to find
    out which).  Don't pass an in_channel containing an unconnected non listening
    socket.<br/>
	  
<br/><code class="code">file_descr_exn t</code> returns the file descriptor underlying <code class="code">t</code>, unless <code class="code">is_closed t</code>,
    in which case it raises.  One must be very careful when using this function, and
    should try not to, since any uses of the resulting file descriptor are unknown to
    the <code class="code">Fd</code> module, and hence can violate the guarantee it is trying to enforce.<br/>
	  
<br/><code class="code">to_int_exn t</code> returns the the underlying file descriptor as an int.  It has the same
    caveats as <code class="code">file_descr_exn</code>.<br/>
	  
<br/><code class="code">replace t kind</code> is for internal use only, by <code class="code">Unix_syscalls</code>.  It is used when one
    wants to reuse a file descriptor in an fd with a new kind.<br/>
	  

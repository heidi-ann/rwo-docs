<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Conv_error.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Conv" rel="Chapter" href="Conv.html">
<link title="Conv_error" rel="Chapter" href="Conv_error.html">
<link title="Exn_magic" rel="Chapter" href="Exn_magic.html">
<link title="Path" rel="Chapter" href="Path.html">
<link title="Pre_sexp" rel="Chapter" href="Pre_sexp.html">
<link title="Sexp" rel="Chapter" href="Sexp.html">
<link title="Sexp_intf" rel="Chapter" href="Sexp_intf.html">
<link title="Sexp_with_layout" rel="Chapter" href="Sexp_with_layout.html">
<link title="Src_pos" rel="Chapter" href="Src_pos.html">
<link title="Std" rel="Chapter" href="Std.html">
<link title="Type" rel="Chapter" href="Type.html">
<link title="Type_with_layout" rel="Chapter" href="Type_with_layout.html">
<link title="Parser" rel="Chapter" href="Parser.html">
<link title="Parser_with_layout" rel="Chapter" href="Parser_with_layout.html">
<link title="Lexer" rel="Chapter" href="Lexer.html"><link title="Type aliases" rel="Section" href="#6_Typealiases">
<link title="Conversion of OCaml-values to S-expressions" rel="Section" href="#6_ConversionofOCamlvaluestoSexpressions">
<link title="Conversion of S-expressions to OCaml-values" rel="Section" href="#6_ConversionofSexpressionstoOCamlvalues">
<title>Conv</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Conv_error.html" title="Conv_error">Next</a>
</div>
<h1>Module <a href="type_Conv.html">Conv</a></h1>
<pre><span class="keyword">module</span> Conv: <code class="code">sig</code> <a href="Conv.html">..</a> <code class="code">end</code></pre><div class="info">
Utility Module for S-expression Conversions<br>
</div>
<hr width="100%">
<pre><span id="TYPEsexp_bool"><span class="keyword">type</span> <code class="type"></code>sexp_bool</span> = <code class="type">bool</code> </pre>
<div class="info">
Dummy definitions for "optional" options, lists, and for opaque types<br>
</div>

<pre><span id="TYPEsexp_option"><span class="keyword">type</span> <code class="type">'a</code> sexp_option</span> = <code class="type">'a option</code> </pre>

<pre><span id="TYPEsexp_list"><span class="keyword">type</span> <code class="type">'a</code> sexp_list</span> = <code class="type">'a list</code> </pre>

<pre><span id="TYPEsexp_array"><span class="keyword">type</span> <code class="type">'a</code> sexp_array</span> = <code class="type">'a array</code> </pre>

<pre><span id="TYPEsexp_opaque"><span class="keyword">type</span> <code class="type">'a</code> sexp_opaque</span> = <code class="type">'a</code> </pre>

<br>
<h6 id="6_Typealiases">Type aliases</h6><br>
<pre><span id="TYPEbigstring"><span class="keyword">type</span> <code class="type"></code>bigstring</span> = <code class="type">Sexp.bigstring</code> </pre>

<pre><span id="TYPEfloat32_vec"><span class="keyword">type</span> <code class="type"></code>float32_vec</span> = <code class="type">(float, Bigarray.float32_elt, Bigarray.fortran_layout) Bigarray.Array1.t</code> </pre>

<pre><span id="TYPEfloat64_vec"><span class="keyword">type</span> <code class="type"></code>float64_vec</span> = <code class="type">(float, Bigarray.float64_elt, Bigarray.fortran_layout) Bigarray.Array1.t</code> </pre>

<pre><span id="TYPEvec"><span class="keyword">type</span> <code class="type"></code>vec</span> = <code class="type"><a href="Conv.html#TYPEfloat64_vec">float64_vec</a></code> </pre>

<pre><span id="TYPEfloat32_mat"><span class="keyword">type</span> <code class="type"></code>float32_mat</span> = <code class="type">(float, Bigarray.float32_elt, Bigarray.fortran_layout) Bigarray.Array2.t</code> </pre>

<pre><span id="TYPEfloat64_mat"><span class="keyword">type</span> <code class="type"></code>float64_mat</span> = <code class="type">(float, Bigarray.float64_elt, Bigarray.fortran_layout) Bigarray.Array2.t</code> </pre>

<pre><span id="TYPEmat"><span class="keyword">type</span> <code class="type"></code>mat</span> = <code class="type"><a href="Conv.html#TYPEfloat64_mat">float64_mat</a></code> </pre>

<br>
<h6 id="6_ConversionofOCamlvaluestoSexpressions">Conversion of OCaml-values to S-expressions</h6><br>
<pre><span id="VALdefault_string_of_float"><span class="keyword">val</span> default_string_of_float</span> : <code class="type">(float -> string) Pervasives.ref</code></pre><div class="info">
<code class="code">default_string_of_float</code> reference to the default function used
    to convert floats to strings.
<p>

    Initially set to <code class="code">fun n -&gt; sprintf "%.20G" n</code>.<br>
</div>
<pre><span id="VALwrite_old_option_format"><span class="keyword">val</span> write_old_option_format</span> : <code class="type">bool Pervasives.ref</code></pre><div class="info">
<code class="code">write_old_option_format</code> reference for the default option format
    used to write option values.  If set to <code class="code">true</code>, the old-style option
    format will be used, the new-style one otherwise.
<p>

    Initially set to <code class="code">true</code>.<br>
</div>
<pre><span id="VALread_old_option_format"><span class="keyword">val</span> read_old_option_format</span> : <code class="type">bool Pervasives.ref</code></pre><div class="info">
<code class="code">read_old_option_format</code> reference for the default option format
    used to read option values.  <code class="code">Of_sexp_error</code> will be raised
    with old-style option values if this reference is set to <code class="code">false</code>.
    Reading new-style option values is always supported.  Using a global
    reference instead of changing the converter calling conventions is
    the only way to avoid breaking old code with the standard macros.
<p>

    Initially set to <code class="code">true</code>.<br>
</div>
<pre><span id="VALlist_map"><span class="keyword">val</span> list_map</span> : <code class="type">('a -> 'b) -> 'a list -> 'b list</code></pre><div class="info">
We re-export a tail recursive map function, because some modules
    override the standard library functions (e.g. <code class="code">StdLabels</code>) which
    wrecks havoc with the camlp4 extension.<br>
</div>
<pre><span id="VALsexp_of_unit"><span class="keyword">val</span> sexp_of_unit</span> : <code class="type">unit -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_unit ()</code> converts a value of type <code class="code">unit</code> to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_bool"><span class="keyword">val</span> sexp_of_bool</span> : <code class="type">bool -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_bool b</code> converts the value <code class="code">x</code> of type <code class="code">bool</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_string"><span class="keyword">val</span> sexp_of_string</span> : <code class="type">string -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_bool str</code> converts the value <code class="code">str</code> of type <code class="code">string</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_char"><span class="keyword">val</span> sexp_of_char</span> : <code class="type">char -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_char c</code> converts the value <code class="code">c</code> of type <code class="code">char</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_int"><span class="keyword">val</span> sexp_of_int</span> : <code class="type">int -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_int n</code> converts the value <code class="code">n</code> of type <code class="code">int</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_float"><span class="keyword">val</span> sexp_of_float</span> : <code class="type">float -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_float n</code> converts the value <code class="code">n</code> of type <code class="code">float</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_int32"><span class="keyword">val</span> sexp_of_int32</span> : <code class="type">int32 -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_int32 n</code> converts the value <code class="code">n</code> of type <code class="code">int32</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_int64"><span class="keyword">val</span> sexp_of_int64</span> : <code class="type">int64 -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_int64 n</code> converts the value <code class="code">n</code> of type <code class="code">int64</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_nativeint"><span class="keyword">val</span> sexp_of_nativeint</span> : <code class="type">nativeint -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_nativeint n</code> converts the value <code class="code">n</code> of type <code class="code">nativeint</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_big_int"><span class="keyword">val</span> sexp_of_big_int</span> : <code class="type">Big_int.big_int -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_big_int n</code> converts the value <code class="code">n</code> of type <code class="code">Big_int.big_int</code>
    to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_nat"><span class="keyword">val</span> sexp_of_nat</span> : <code class="type">Nat.nat -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_nat n</code> converts the value <code class="code">n</code> of type <code class="code">Nat.nat</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_num"><span class="keyword">val</span> sexp_of_num</span> : <code class="type">Num.num -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_num n</code> converts the value <code class="code">n</code> of type <code class="code">Num.num</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_ratio"><span class="keyword">val</span> sexp_of_ratio</span> : <code class="type">Ratio.ratio -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_ratio n</code> converts the value <code class="code">n</code> of type <code class="code">Ratio.ratio</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_ref"><span class="keyword">val</span> sexp_of_ref</span> : <code class="type">('a -> Sexp.t) -> 'a Pervasives.ref -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_ref conv r</code> converts the value <code class="code">r</code> of type <code class="code">'a ref</code> to
    an S-expression.  Uses <code class="code">conv</code> to convert values of type <code class="code">'a</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_lazy_t"><span class="keyword">val</span> sexp_of_lazy_t</span> : <code class="type">('a -> Sexp.t) -> 'a lazy_t -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_lazy_t conv l</code> converts the value <code class="code">l</code> of type <code class="code">'a lazy_t</code> to
    an S-expression.  Uses <code class="code">conv</code> to convert values of type <code class="code">'a</code> to an
    S-expression.<br>
</div>
<pre><span id="VALsexp_of_option"><span class="keyword">val</span> sexp_of_option</span> : <code class="type">('a -> Sexp.t) -> 'a option -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_option conv opt</code> converts the value <code class="code">opt</code> of type <code class="code">'a
    option</code> to an S-expression.  Uses <code class="code">conv</code> to convert values of type
    <code class="code">'a</code> to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_pair"><span class="keyword">val</span> sexp_of_pair</span> : <code class="type">('a -> Sexp.t) -> ('b -> Sexp.t) -> 'a * 'b -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_pair conv1 conv2 pair</code> converts a pair to an S-expression.
    It uses its first argument to convert the first element of the pair,
    and its second argument to convert the second element of the pair.<br>
</div>
<pre><span id="VALsexp_of_triple"><span class="keyword">val</span> sexp_of_triple</span> : <code class="type">('a -> Sexp.t) -> ('b -> Sexp.t) -> ('c -> Sexp.t) -> 'a * 'b * 'c -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_triple conv1 conv2 conv3 triple</code> converts a triple to
    an S-expression using <code class="code">conv1</code>, <code class="code">conv2</code>, and <code class="code">conv3</code> to convert its
    elements.<br>
</div>
<pre><span id="VALsexp_of_list"><span class="keyword">val</span> sexp_of_list</span> : <code class="type">('a -> Sexp.t) -> 'a list -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_list conv lst</code> converts the value <code class="code">lst</code> of type <code class="code">'a
    list</code> to an S-expression.  Uses <code class="code">conv</code> to convert values of type
    <code class="code">'a</code> to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_array"><span class="keyword">val</span> sexp_of_array</span> : <code class="type">('a -> Sexp.t) -> 'a array -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_array conv ar</code> converts the value <code class="code">ar</code> of type <code class="code">'a
    array</code> to an S-expression.  Uses <code class="code">conv</code> to convert values of type
    <code class="code">'a</code> to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_hashtbl"><span class="keyword">val</span> sexp_of_hashtbl</span> : <code class="type">('a -> Sexp.t) -> ('b -> Sexp.t) -> ('a, 'b) Hashtbl.t -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_hashtbl conv_key conv_value htbl</code> converts the value <code class="code">htbl</code>
    of type <code class="code">('a, 'b) Hashtbl.t</code> to an S-expression.  Uses <code class="code">conv_key</code>
    to convert the hashtable keys of type <code class="code">'a</code>, and <code class="code">conv_value</code> to
    convert hashtable values of type <code class="code">'b</code> to S-expressions.<br>
</div>
<pre><span id="VALsexp_of_bigstring"><span class="keyword">val</span> sexp_of_bigstring</span> : <code class="type"><a href="Conv.html#TYPEbigstring">bigstring</a> -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_bigstring bstr</code> converts a bigstring (character bigarray
    in C-layout) to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_float32_vec"><span class="keyword">val</span> sexp_of_float32_vec</span> : <code class="type"><a href="Conv.html#TYPEfloat32_vec">float32_vec</a> -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_float32_vec vec</code> converts the one-dimensional bigarray
    <code class="code">vec</code> of 32-bit floats in Fortran-layout to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_float64_vec"><span class="keyword">val</span> sexp_of_float64_vec</span> : <code class="type"><a href="Conv.html#TYPEfloat64_vec">float64_vec</a> -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_float64_vec vec</code> converts the one-dimensional bigarray
    <code class="code">vec</code> of 64-bit floats in Fortran-layout to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_vec"><span class="keyword">val</span> sexp_of_vec</span> : <code class="type"><a href="Conv.html#TYPEvec">vec</a> -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_vec vec</code> same as <a href="Conv.html#VALsexp_of_float64_vec"><code class="code">Conv.sexp_of_float64_vec</code></a>.<br>
</div>
<pre><span id="VALsexp_of_float32_mat"><span class="keyword">val</span> sexp_of_float32_mat</span> : <code class="type"><a href="Conv.html#TYPEfloat32_mat">float32_mat</a> -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_float32_mat mat</code> converts the two-dimensional bigarray
    <code class="code">mat</code> of 32-bit floats in Fortran-layout to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_float64_mat"><span class="keyword">val</span> sexp_of_float64_mat</span> : <code class="type"><a href="Conv.html#TYPEfloat64_mat">float64_mat</a> -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_float64_mat mat</code> converts the two-dimensional bigarray
    <code class="code">mat</code> of 64-bit floats in Fortran-layout to an S-expression.<br>
</div>
<pre><span id="VALsexp_of_mat"><span class="keyword">val</span> sexp_of_mat</span> : <code class="type"><a href="Conv.html#TYPEmat">mat</a> -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_mat mat</code> same as <a href="Conv.html#VALsexp_of_float64_mat"><code class="code">Conv.sexp_of_float64_mat</code></a>.<br>
</div>
<pre><span id="VALsexp_of_opaque"><span class="keyword">val</span> sexp_of_opaque</span> : <code class="type">'a -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_opaque x</code> converts the value <code class="code">x</code> of opaque type to an
    S-expression.  This means the user need not provide converters,
    but the result cannot be interpreted.<br>
</div>
<pre><span id="VALsexp_of_fun"><span class="keyword">val</span> sexp_of_fun</span> : <code class="type">('a -> 'b) -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_fun f</code> converts the value <code class="code">f</code> of function type to a
    dummy S-expression.  Functions cannot be serialized as S-expressions,
    but at least a placeholder can be generated for pretty-printing.<br>
</div>
<pre><span id="VALstring_of__of__sexp_of"><span class="keyword">val</span> string_of__of__sexp_of</span> : <code class="type">('a -> Sexp.t) -> 'a -> string</code></pre><div class="info">
<code class="code">string_of__of__sexp_of conv x</code> converts the OCaml-value <code class="code">x</code> to
    an S-expression represented as a string by using conversion function
    <code class="code">conv</code>.<br>
</div>
<br>
<h6 id="6_ConversionofSexpressionstoOCamlvalues">Conversion of S-expressions to OCaml-values</h6><br>
<pre><span id="EXCEPTIONOf_sexp_error"><span class="keyword">exception</span> Of_sexp_error</span> <span class="keyword">of</span> <code class="type">exn * Sexp.t</code></pre>
<div class="info">
<code class="code">Of_sexp_error (exn, sexp)</code> the exception raised when an S-expression
    could not be successfully converted to an OCaml-value.<br>
</div>
<pre><span id="VALrecord_check_extra_fields"><span class="keyword">val</span> record_check_extra_fields</span> : <code class="type">bool Pervasives.ref</code></pre><div class="info">
<code class="code">record_check_extra_fields</code> checks for extra (= unknown) fields
    in record S-expressions.<br>
</div>
<pre><span id="VALof_sexp_error"><span class="keyword">val</span> of_sexp_error</span> : <code class="type">string -> Sexp.t -> 'a</code></pre><div class="info">
<code class="code">of_sexp_error reason sexp</code><br>
<b>Raises</b> <code>Of_sexp_error</code> (Failure reason, sexp).<br>
</div>
<pre><span id="VALof_sexp_error_exn"><span class="keyword">val</span> of_sexp_error_exn</span> : <code class="type">exn -> Sexp.t -> 'a</code></pre><div class="info">
<code class="code">of_sexp_error exc sexp</code><br>
<b>Raises</b> <code>Of_sexp_error</code> (exc, sexp).<br>
</div>
<pre><span id="VALunit_of_sexp"><span class="keyword">val</span> unit_of_sexp</span> : <code class="type">Sexp.t -> unit</code></pre><div class="info">
<code class="code">unit_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">unit</code>.<br>
</div>
<pre><span id="VALbool_of_sexp"><span class="keyword">val</span> bool_of_sexp</span> : <code class="type">Sexp.t -> bool</code></pre><div class="info">
<code class="code">bool_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">bool</code>.<br>
</div>
<pre><span id="VALstring_of_sexp"><span class="keyword">val</span> string_of_sexp</span> : <code class="type">Sexp.t -> string</code></pre><div class="info">
<code class="code">string_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">string</code>.<br>
</div>
<pre><span id="VALchar_of_sexp"><span class="keyword">val</span> char_of_sexp</span> : <code class="type">Sexp.t -> char</code></pre><div class="info">
<code class="code">char_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">char</code>.<br>
</div>
<pre><span id="VALint_of_sexp"><span class="keyword">val</span> int_of_sexp</span> : <code class="type">Sexp.t -> int</code></pre><div class="info">
<code class="code">int_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">int</code>.<br>
</div>
<pre><span id="VALfloat_of_sexp"><span class="keyword">val</span> float_of_sexp</span> : <code class="type">Sexp.t -> float</code></pre><div class="info">
<code class="code">float_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">float</code>.<br>
</div>
<pre><span id="VALint32_of_sexp"><span class="keyword">val</span> int32_of_sexp</span> : <code class="type">Sexp.t -> int32</code></pre><div class="info">
<code class="code">int32_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">int32</code>.<br>
</div>
<pre><span id="VALint64_of_sexp"><span class="keyword">val</span> int64_of_sexp</span> : <code class="type">Sexp.t -> int64</code></pre><div class="info">
<code class="code">int64_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value of type
    <code class="code">int64</code>.<br>
</div>
<pre><span id="VALnativeint_of_sexp"><span class="keyword">val</span> nativeint_of_sexp</span> : <code class="type">Sexp.t -> nativeint</code></pre><div class="info">
<code class="code">nativeint_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">nativeint</code>.<br>
</div>
<pre><span id="VALbig_int_of_sexp"><span class="keyword">val</span> big_int_of_sexp</span> : <code class="type">Sexp.t -> Big_int.big_int</code></pre><div class="info">
<code class="code">big_int_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">Big_int.big_int</code>.<br>
</div>
<pre><span id="VALnat_of_sexp"><span class="keyword">val</span> nat_of_sexp</span> : <code class="type">Sexp.t -> Nat.nat</code></pre><div class="info">
<code class="code">nat_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">Nat.nat</code>.<br>
</div>
<pre><span id="VALnum_of_sexp"><span class="keyword">val</span> num_of_sexp</span> : <code class="type">Sexp.t -> Num.num</code></pre><div class="info">
<code class="code">num_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">Nat.num</code>.<br>
</div>
<pre><span id="VALratio_of_sexp"><span class="keyword">val</span> ratio_of_sexp</span> : <code class="type">Sexp.t -> Ratio.ratio</code></pre><div class="info">
<code class="code">ratio_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">Nat.ratio</code>.<br>
</div>
<pre><span id="VALref_of_sexp"><span class="keyword">val</span> ref_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> Sexp.t -> 'a Pervasives.ref</code></pre><div class="info">
<code class="code">ref_of_sexp conv sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">'a ref</code> using conversion function <code class="code">conv</code>, which converts
    an S-expression to a value of type <code class="code">'a</code>.<br>
</div>
<pre><span id="VALlazy_t_of_sexp"><span class="keyword">val</span> lazy_t_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> Sexp.t -> 'a lazy_t</code></pre><div class="info">
<code class="code">lazy_t_of_sexp conv sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">'a lazy_t</code> using conversion function <code class="code">conv</code>, which converts
    an S-expression to a value of type <code class="code">'a</code>.<br>
</div>
<pre><span id="VALoption_of_sexp"><span class="keyword">val</span> option_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> Sexp.t -> 'a option</code></pre><div class="info">
<code class="code">option_of_sexp conv sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">'a option</code> using conversion function <code class="code">conv</code>, which converts
    an S-expression to a value of type <code class="code">'a</code>.<br>
</div>
<pre><span id="VALpair_of_sexp"><span class="keyword">val</span> pair_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> (Sexp.t -> 'b) -> Sexp.t -> 'a * 'b</code></pre><div class="info">
<code class="code">pair_of_sexp conv1 conv2 sexp</code> converts S-expression <code class="code">sexp</code> to a pair
    of type <code class="code">'a * 'b</code> using conversion functions <code class="code">conv1</code> and <code class="code">conv2</code>,
    which convert S-expressions to values of type <code class="code">'a</code> and <code class="code">'b</code>
    respectively.<br>
</div>
<pre><span id="VALtriple_of_sexp"><span class="keyword">val</span> triple_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> (Sexp.t -> 'b) -> (Sexp.t -> 'c) -> Sexp.t -> 'a * 'b * 'c</code></pre><div class="info">
<code class="code">triple_of_sexp conv1 conv2 conv3 sexp</code> converts S-expression <code class="code">sexp</code>
    to a triple of type <code class="code">'a * 'b * 'c</code> using conversion functions <code class="code">conv1</code>,
    <code class="code">conv2</code>, and <code class="code">conv3</code>, which convert S-expressions to values of type
    <code class="code">'a</code>, <code class="code">'b</code>, and <code class="code">'c</code> respectively.<br>
</div>
<pre><span id="VALlist_of_sexp"><span class="keyword">val</span> list_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> Sexp.t -> 'a list</code></pre><div class="info">
<code class="code">list_of_sexp conv sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">'a list</code> using conversion function <code class="code">conv</code>, which converts
    an S-expression to a value of type <code class="code">'a</code>.<br>
</div>
<pre><span id="VALarray_of_sexp"><span class="keyword">val</span> array_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> Sexp.t -> 'a array</code></pre><div class="info">
<code class="code">array_of_sexp conv sexp</code> converts S-expression <code class="code">sexp</code> to a value
    of type <code class="code">'a array</code> using conversion function <code class="code">conv</code>, which converts
    an S-expression to a value of type <code class="code">'a</code>.<br>
</div>
<pre><span id="VALhashtbl_of_sexp"><span class="keyword">val</span> hashtbl_of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> (Sexp.t -> 'b) -> Sexp.t -> ('a, 'b) Hashtbl.t</code></pre><div class="info">
<code class="code">hashtbl_of_sexp conv_key conv_value sexp</code> converts S-expression
    <code class="code">sexp</code> to a value of type <code class="code">('a, 'b) Hashtbl.t</code> using conversion
    function <code class="code">conv_key</code>, which converts an S-expression to hashtable
    key of type <code class="code">'a</code>, and function <code class="code">conv_value</code>, which converts an
    S-expression to hashtable value of type <code class="code">'b</code>.<br>
</div>
<pre><span id="VALbigstring_of_sexp"><span class="keyword">val</span> bigstring_of_sexp</span> : <code class="type">Sexp.t -> <a href="Conv.html#TYPEbigstring">bigstring</a></code></pre><div class="info">
<code class="code">bigstring_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a
    bigstring (character bigarray in C-layout).<br>
</div>
<pre><span id="VALfloat32_vec_of_sexp"><span class="keyword">val</span> float32_vec_of_sexp</span> : <code class="type">Sexp.t -> <a href="Conv.html#TYPEfloat32_vec">float32_vec</a></code></pre><div class="info">
<code class="code">float32_vec_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a
    one-dimensional bigarray of 32-bit floats in Fortran-layout.<br>
</div>
<pre><span id="VALfloat64_vec_of_sexp"><span class="keyword">val</span> float64_vec_of_sexp</span> : <code class="type">Sexp.t -> <a href="Conv.html#TYPEfloat64_vec">float64_vec</a></code></pre><div class="info">
<code class="code">float64_vec_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a
    one-dimensional bigarray of 64-bit floats in Fortran-layout.<br>
</div>
<pre><span id="VALvec_of_sexp"><span class="keyword">val</span> vec_of_sexp</span> : <code class="type">Sexp.t -> <a href="Conv.html#TYPEvec">vec</a></code></pre><div class="info">
<code class="code">vec_of_sexp sexp</code> same as <a href="Conv.html#VALfloat64_vec_of_sexp"><code class="code">Conv.float64_vec_of_sexp</code></a>.<br>
</div>
<pre><span id="VALfloat32_mat_of_sexp"><span class="keyword">val</span> float32_mat_of_sexp</span> : <code class="type">Sexp.t -> <a href="Conv.html#TYPEfloat32_mat">float32_mat</a></code></pre><div class="info">
<code class="code">float32_mat_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a
    two-dimensional bigarray of 32-bit floats in Fortran-layout.<br>
</div>
<pre><span id="VALfloat64_mat_of_sexp"><span class="keyword">val</span> float64_mat_of_sexp</span> : <code class="type">Sexp.t -> <a href="Conv.html#TYPEfloat64_mat">float64_mat</a></code></pre><div class="info">
<code class="code">float64_mat_of_sexp sexp</code> converts S-expression <code class="code">sexp</code> to a
    two-dimensional bigarray of 64-bit floats in Fortran-layout.<br>
</div>
<pre><span id="VALmat_of_sexp"><span class="keyword">val</span> mat_of_sexp</span> : <code class="type">Sexp.t -> <a href="Conv.html#TYPEmat">mat</a></code></pre><div class="info">
<code class="code">mat_of_sexp sexp</code> same as <a href="Conv.html#VALfloat64_mat_of_sexp"><code class="code">Conv.float64_mat_of_sexp</code></a>.<br>
</div>
<pre><span id="VALopaque_of_sexp"><span class="keyword">val</span> opaque_of_sexp</span> : <code class="type">Sexp.t -> 'a</code></pre><div class="info">
<code class="code">opaque_of_sexp sexp</code><br>
<b>Raises</b> <code>Of_sexp_error</code> when attempting to
    convert an S-expression to an opaque value.<br>
</div>
<pre><span id="VALfun_of_sexp"><span class="keyword">val</span> fun_of_sexp</span> : <code class="type">Sexp.t -> 'a</code></pre><div class="info">
<code class="code">fun_of_sexp sexp</code><br>
<b>Raises</b> <code>Of_sexp_error</code> when attempting to
    convert an S-expression to a function.<br>
</div>
<pre><span id="VALof_string__of__of_sexp"><span class="keyword">val</span> of_string__of__of_sexp</span> : <code class="type">(Sexp.t -> 'a) -> string -> 'a</code></pre><div class="info">
<code class="code">of_string__of__of_sexp conv str</code> converts the S-expression <code class="code">str</code>
    represented as a string to an OCaml-value by using conversion function
    <code class="code">conv</code>.<br>
</div>
<br>
Exception converters<br>
<pre><span id="VALsexp_of_exn"><span class="keyword">val</span> sexp_of_exn</span> : <code class="type">exn -> Sexp.t</code></pre><div class="info">
<code class="code">sexp_of_exn exc</code> converts exception <code class="code">exc</code> to an S-expression.
    If no suitable converter is found, the standard converter in
    <code class="code">Printexc</code> will be used to generate an atomic S-expression.<br>
</div>
<pre><span id="VALsexp_of_exn_opt"><span class="keyword">val</span> sexp_of_exn_opt</span> : <code class="type">exn -> Sexp.t option</code></pre><div class="info">
<code class="code">sexp_of_exn_opt exc</code> converts exception <code class="code">exc</code> to <code class="code">Some sexp</code>.
    If no suitable converter is found, <code class="code">None</code> is returned instead.<br>
</div>
<pre><span class="keyword">module</span> <a href="Conv.Exn_converter.html">Exn_converter</a>: <code class="code">sig</code> <a href="Conv.Exn_converter.html">..</a> <code class="code">end</code></pre></body></html>
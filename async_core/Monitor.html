<!DOCTYPE HTML>
<html>
<head>

<title>Monitor</title>
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type"/>
<link rel="stylesheet" href="style.css" type="text/css"/>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"> </script>
<script type="text/javascript" src="doc_loader.js"> </script>
</head>
<body>

<h1>Module Monitor</h1>
<pre><span class="keyword">module</span> Monitor</pre><div class="info">A monitor is a context that determines what to do when there is an unhandled
    exception.  Every Async computation runs within the context of some monitor, which,
    when the computation is running, is referred to as the &quot;current&quot; monitor.  Monitors
    are arranged in a tree -- when a new monitor is created, it is a child of the current
    monitor.<br/>    One can listen to a monitor using Monitor.errors to learn when the monitor sees an
    error.<br/>    If a computation raises an unhandled exception, the current monitor does one of two
    things.  If anyone is listening to the monitor (i.e. Monitor.errors has been called on
    the monitor), then the error stream is extended, and the listeners are responsible for
    doing something.  If no one is &quot;listening&quot; to the monitor, then the exception is
    raised to monitor's parent.  The initial monitor, i.e. the root of the monitor tree,
    prints an unhandled-exception message and calls exit 1.<br/>*************** NOTE ABOUT THE TOPLEVEL MONITOR ****************<br/>    It is important to note that in the toplevel monitor, exceptions will only be caught
    in the async part of a computation.  For example, in:<br/>    <pre class="codepre"><code class="code">
      upon (f ()) g
    </code></pre><br/>    if <code class="code">f</code> raises, the exception will not go to a monitor; it will go to the next caml
    exception handler on the stack.  Any exceptions raised by <code class="code">g</code> will be caught by the
    scheduler and propagated to the toplevel monitor.  Because of this it is advised to
    always use <code class="code">Scheduler.schedule</code> or <code class="code">Scheduler.within</code>.  For example:<br/>    <pre class="codepre"><code class="code">
      Scheduler.within (fun () -&gt; upon (f ()) g)
    </code></pre><br/>    This code will catch an exception in either <code class="code">f</code> or <code class="code">g</code>, and propagate it to the
    monitor.<br/>    This is only relevant to the toplevel monitor because if you create another monitor
    and you wish to run code within it you have no choice but to use <code class="code">Scheduler.within</code>.
    <code class="code">try_with</code> creates its own monitor and uses <code class="code">Scheduler.within</code>, so it does not have
    this problem.</div>
<hr/>
<div file="Monitor.html.contents" class="content_to_load"> </div>
</body>
</html>
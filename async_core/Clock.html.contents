 
      <pre><span><span class="keyword">val</span> run_at : <code class="type"><a href="../core/Std.Time.html#TYPEt">Core.Std.Time.t</a> -&gt; ('a -&gt; unit) -&gt; 'a -&gt; unit</code></span></pre>
      <div class="info"><code class="code">run_at time f a</code> runs <code class="code">f a</code> as soon as possible after <code class="code">time</code>.  If <code class="code">time</code> is in the
    past, then <code class="code">run_at</code> will immediately schedule a job t that will run <code class="code">f a</code>.  In no
    situation will <code class="code">run_at</code> actually call <code class="code">f</code> itself.  The call to <code class="code">f</code> will always be in
    another job.<br/>    <code class="code">run_after</code> is like <code class="code">run_at</code>, except that one specifies a time span rather than an
    absolute time.</div>
    
 
      <pre><span><span class="keyword">val</span> run_after : <code class="type"><a href="../core/Std.Time.Span.html#TYPEt">Core.Std.Time.Span.t</a> -&gt; ('a -&gt; unit) -&gt; 'a -&gt; unit</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> at : <code class="type"><a href="../core/Std.Time.html#TYPEt">Core.Std.Time.t</a> -&gt; unit <a href="Deferred.html#TYPEt">Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">at time</code> returns a deferred <code class="code">d</code> that will become determined as soon as possible after
    <code class="code">time</code><br/>    <code class="code">after</code> is like <code class="code">at</code>, except that one specifies a time span rather than an absolute
    time.<br/>    If you set up a lot of <code class="code">after</code> events at the beginning of your program they will
    trigger at the same time.  Use <code class="code">Time.Span.randomize</code> to even that out.</div>
    
 
      <pre><span><span class="keyword">val</span> after : <code class="type"><a href="../core/Std.Time.Span.html#TYPEt">Core.Std.Time.Span.t</a> -&gt; unit <a href="Deferred.html#TYPEt">Deferred.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> with_timeout : <code class="type"><a href="../core/Std.Time.Span.html#TYPEt">Core.Std.Time.Span.t</a> -&gt;
'a <a href="Deferred.html#TYPEt">Deferred.t</a> -&gt; [ `Result of 'a | `Timeout ] <a href="Deferred.html#TYPEt">Deferred.t</a></code></span></pre>
      <div class="info"><code class="code">with_timeout span d</code> does pretty much what one would expect.  Note that at the point
    of checking if <code class="code">d</code> is determined and the timeout has expired, the resulting deferred
    will be determined with <code class="code">`Result</code>.  In other words, since there is inherent race
    between <code class="code">d</code> and the timeout, the preference is given to <code class="code">d</code>.</div>
    
<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Clock.Event.html">Event</a> : <code class="code">sig</code> <a href="Clock.Event.html">..</a> <code class="code">end</code></pre><div class="info">Events provide abortable versions of <code class="code">at</code> and <code class="code">after</code>.</div>
	<div class="content" style="display:none">
	<div file="Clock.Event.html.contents" class="content_to_load"> </div>
	</div>
  </div>
 
      <pre><span><span class="keyword">val</span> at_varying_intervals : <code class="type">?stop:unit <a href="Deferred.html#TYPEt">Deferred.t</a> -&gt;
(unit -&gt; <a href="../core/Std.Time.Span.html#TYPEt">Core.Std.Time.Span.t</a>) -&gt; unit <a href="Async_stream.html#TYPEt">Async_stream.t</a></code></span></pre>
      <div class="info"><code class="code">at_varying_intervals f ?stop</code> returns a stream whose next element becomes determined
    by calling <code class="code">f ()</code> and waiting for that amount of time, and then looping to determine
    subsequent elements.  The stream will end after <code class="code">stop</code> becomes determined.</div>
    
 
      <pre><span><span class="keyword">val</span> at_intervals : <code class="type">?start:<a href="../core/Std.Time.html#TYPEt">Core.Std.Time.t</a> -&gt;
?stop:unit <a href="Deferred.html#TYPEt">Deferred.t</a> -&gt; <a href="../core/Std.Time.Span.html#TYPEt">Core.Std.Time.Span.t</a> -&gt; unit <a href="Async_stream.html#TYPEt">Async_stream.t</a></code></span></pre>
      <div class="info"><code class="code">at_intervals interval ?start ?stop</code> returns a stream whose elements will become
    determined at nonnegative integer multiples of <code class="code">interval</code> after the <code class="code">start</code> time,
    until <code class="code">stop</code> becomes determined:<br/>    <span class="verbatim">       start + 0 * interval
       start + 1 * interval
       start + 2 * interval
       start + 3 * interval
       ...
    </span><br/>    If the interval is too small or the CPU is too loaded, <code class="code">at_intervals</code> will skip
    until the next upcoming multiple of <code class="code">interval</code> after start.</div>
    
 
      <pre><span><span class="keyword">val</span> every' : <code class="type">?start:unit <a href="Deferred.html#TYPEt">Deferred.t</a> -&gt;
?stop:unit <a href="Deferred.html#TYPEt">Deferred.t</a> -&gt;
?continue_on_error:bool -&gt;
<a href="../core/Std.Time.Span.html#TYPEt">Core.Std.Time.Span.t</a> -&gt; (unit -&gt; unit <a href="Deferred.html#TYPEt">Deferred.t</a>) -&gt; unit</code></span></pre>
      <div class="info"><code class="code">every' ?start ?stop span f</code> runs <code class="code">f()</code> every <code class="code">span</code> amount of time starting when
    <code class="code">start</code> becomes determined and stopping when <code class="code">stop</code> becomes determined.  <code class="code">every</code> waits
    until the result of <code class="code">f()</code> becomes determined before waiting for the next <code class="code">span</code>.<br/>    It is guaranteed that if <code class="code">stop</code> becomes determined, even during evaluation of <code class="code">f</code>,
    then <code class="code">f</code> will not be called again by a subsequent iteration of the loop.<br/>    It is an error for <code class="code">span</code> to be nonpositive.</div>
    
 
      <pre><span><span class="keyword">val</span> every : <code class="type">?start:unit <a href="Deferred.html#TYPEt">Deferred.t</a> -&gt;
?stop:unit <a href="Deferred.html#TYPEt">Deferred.t</a> -&gt;
?continue_on_error:bool -&gt; <a href="../core/Std.Time.Span.html#TYPEt">Core.Std.Time.Span.t</a> -&gt; (unit -&gt; unit) -&gt; unit</code></span></pre>
      <div class="info"><code class="code">every ?start ?stop span f</code> is
    <code class="code">every' ?start ?stop span (fun () -&gt; f (); Deferred.unit)</code> </div>
    

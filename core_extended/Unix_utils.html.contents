<br/><br/><h2 id="2_TITLE">Handling RAM limits</h2><br/> <br/>
	  
 
      <pre><span><span class="keyword">val</span> physical_ram : <code class="type">unit -&gt; int64</code></span></pre>
      <div class="info"><code class="code">physical_ram ()</code> <b>Returns</b> the total amount of physical RAM in bytes.</div>
    
 
      <pre><span><span class="keyword">val</span> ram_limit_spec : <code class="type"><a href="../core/Std.Arg.html#TYPEt">Core.Std.Arg.t</a></code></span></pre>
      <div class="info"><code class="code">ram_limit_spec</code> command line arguments to set ram limits.</div>
    
<br/><br/><h2 id="2_TITLE">Signal handling</h2><br/> <br/>
	  
 
      <pre><span><span class="keyword">val</span> wrap_block_signals : <code class="type">(unit -&gt; 'a) -&gt; 'a</code></span></pre>
      <div class="info"><code class="code">wrap_block_signals f</code> blocks all signals before execution of <code class="code">f</code>, and
    restores them afterwards.</div>
    
 
      <pre><span><span class="keyword">val</span> ensure_at_exit : <code class="type">unit -&gt; unit</code></span></pre>
      <div class="info"><code class="code">ensure_at_exit ()</code>: catch all signals, run at_exit functions,
    then re-deliver the signal to self to ensure the default behavior.
    at_exit functions are honored only when terminating by exit, not by signals,
    so we need to do some tricks to get it run by signals too</div>
    
 
      <pre><span><span class="keyword">val</span> get_ppids : <code class="type"><a href="../core/Std.Pid.html#TYPEt">Core.Std.Pid.t</a> -&gt; <a href="../core/Std.Pid.html#TYPEt">Core.Std.Pid.t</a> list option</code></span></pre>
      <div class="info"><code class="code">get_ppids pid</code> returns the list of parent pids, up to init (1) for pid.</div>
    

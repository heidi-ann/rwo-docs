 
      <pre><span><span class="keyword">val</span> of_option : <code class="type">'a option -&gt; 'a list</code></span></pre>
      <div class="info"><code class="code">of_option o</code> returns a list that is empty if <code class="code">o</code> is None, otherwise it is a singleton
    list. Useful to get filter_map-like behavior in the context of something like a
    concat_map.</div>
    
 
      <pre><span><span class="keyword">val</span> set_inter : <code class="type">'a list -&gt; 'a list -&gt; 'a list</code></span></pre>
      <div class="info"><code class="code">set_inter l1 l2</code> returns a list without duplicates of all elements of l1 that are in l2</div>
    
 
      <pre><span><span class="keyword">val</span> set_diff : <code class="type">'a list -&gt; 'a list -&gt; 'a list</code></span></pre>
      <div class="info"><code class="code">set_diff l1 l2</code> returns a list of all elements of l1 that are not in l2</div>
    
 
      <pre><span><span class="keyword">val</span> classify : <code class="type">?equal:('b -&gt; 'b -&gt; bool) -&gt; f:('a -&gt; 'b) -&gt; 'a list -&gt; ('b * 'a list) list</code></span></pre>
      <div class="info"><code class="code">classify l ~equal ~f</code> elements <code class="code">x</code> and <code class="code">y</code> of list <code class="code">l</code> are assigned to the
    same class iff <code class="code">equal (f x) (f y)</code> returns true. The default for <code class="code">equal</code> is ( = )</div>
    
 
      <pre><span><span class="keyword">val</span> enumerate_from : <code class="type">int -&gt; 'a list -&gt; ('a * int) list</code></span></pre>
      <div class="info"><code class="code">enumerate_from n xs</code> returns a list of pairs constructed by pairing an
    incrementing counter, starting at <code class="code">n</code>, with the elements of <code class="code">xs</code>.
    e.g.  enumerate_from 1 <code class="code">a,b,c</code>  =  <code class="code">a,1; b,2; c,3</code> </div>
    
 
      <pre><span><span class="keyword">val</span> fold_left_term : <code class="type">'a list -&gt;
f:('b -&gt; 'a -&gt; [ `Continue of 'b | `Final of 'b ]) -&gt; init:'b -&gt; 'b</code></span></pre>
      <div class="info">fold_left_term is like fold_left, except that you can halt early.
    The function to be folded should return a bool along with the new
    accumulator.  True indicates that it should continue, false means
    it should halt</div>
    
 
      <pre><span><span class="keyword">val</span> map_accum : <code class="type">'a list -&gt; f:('b -&gt; 'a -&gt; 'b * 'c) -&gt; init:'b -&gt; 'b * 'c list</code></span></pre>
      <div class="info">A combination of <code class="code">map</code> and <code class="code">fold</code>. Applies a function to each element of the input
    list, building up an accumulator, returning both the final state of the accumulator
    and a new list.</div>
    
 
      <pre><span><span class="keyword">val</span> max : <code class="type">?cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> min : <code class="type">?cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> max_exn : <code class="type">?cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> min_exn : <code class="type">?cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> lcs : <code class="type">'a list -&gt; 'a list -&gt; 'a list</code></span></pre>
      <div class="info">Find the longest common subsequence between two list.</div>
    
<br/>Numbers the elements in a list by occurence:<br/>   <code class="code">[a;b;c;a;d] -&gt; [(a,0);(b,0);(c,0);(a,1);(d,0)]</code><br/>
	  
 
      <pre><span><span class="keyword">val</span> number : <code class="type">'a list -&gt; ('a * int) list</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> multimerge : <code class="type">'a list list -&gt; 'a list</code></span></pre>
      <div class="info">Merges several list trying to keep the order in which the elements appear.
   The elements of the individual are not deduped.<br/>   multimerge <code class="code">[[a;b;d;a] [b;c;d]] -&gt; [a;b;c;d;a]</code>
</div>
    
 
      <pre><span><span class="keyword">val</span> multimerge_unique : <code class="type">'a list list -&gt; 'a list</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> square : <code class="type">?null:'v -&gt; ('k * 'v) list list -&gt; 'k list * 'v list list</code></span></pre>
      <div class="info">Takes a list of <code class="code">`key*`value lists</code> and returns a
   header * table_body body that is obtained by splitting the lists and
   re-oddering the terms (so that they all have the same header).<br/>   If <code class="code">null_value</code> is not specified and the rows have different keys
   the function will raise an exception.
   <code class="code">
   square ~null
   [[(1,a_1);(2,b_1);(4,c_1)];
    [(3,a_2)];
    [(0,a_3);(1,b_3);(2,c_3);(3,d_3);(4,e_3)]]
   =
   ([0   ;1   ;2   ;3   ;4],
   [[null;a_1 ;b_1 ;null;c_1 ]
    [null;null;null;a_2 ;null]
    [a_3 ;b_3 ;c_3 ;d_3 ;e_3 ]])
   </code>
</div>
    
 
      <pre><span><span class="keyword">val</span> square_unique : <code class="type">?null:'v -&gt; ('k * 'v) list list -&gt; 'k list * 'v list list</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> equal : <code class="type">equal:('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> compare : <code class="type">cmp:('a -&gt; 'b -&gt; int) -&gt; 'a list -&gt; 'b list -&gt; int</code></span></pre>
      
    

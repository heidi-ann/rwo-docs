<pre><code><span id="TYPEuids"><span class="keyword">type</span> uids </span>= {</code></pre><table class="typetable">
		    <tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTuids.ruid">ruid</span> :<code class="type">int</code>;</code></td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTuids.euid">euid</span> :<code class="type">int</code>;</code></td>
	  </tr><tr><td align="left" valign="top"><code>  </code></td><td align="left" valign="top"><code> <span id="TYPEELTuids.suid">suid</span> :<code class="type">int</code>;</code></td>
	  </tr></table>}
      
    
 
      <pre><span><span class="keyword">val</span> setresuid : <code class="type">(?ruid:int -&gt; ?euid:int -&gt; ?suid:int -&gt; unit -&gt; unit) <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> getresuid : <code class="type">(unit -&gt; <a href="Extended_linux.html#TYPEuids">uids</a>) <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a></code></span></pre>
      
    
<br/><br/><h6 id="6_TITLE">Splicing - zero-copies between kernel buffers</h6><br/> <br/>
	  
<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Extended_linux.Splice.html">Splice</a> : <code class="code">sig</code> <a href="Extended_linux.Splice.html">..</a> <code class="code">end</code></pre>
	<div class="content" style="display:none">
	<div file="Extended_linux.Splice.html.contents" class="content_to_load"> </div>
	</div>
  </div>
<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Extended_linux.Statfs.html">Statfs</a> : <code class="code">sig</code> <a href="Extended_linux.Statfs.html">..</a> <code class="code">end</code></pre>
	<div class="content" style="display:none">
	<div file="Extended_linux.Statfs.html.contents" class="content_to_load"> </div>
	</div>
  </div>
 
      <pre><span><span class="keyword">val</span> statfs : <code class="type">(string -&gt; <a href="Extended_linux.Statfs.html#TYPEt">Statfs.t</a>) <a href="../core/Std.Or_error.html#TYPEt">Core.Std.Or_error.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_uids : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Type_class.html#TYPEt">Core.Std.Bin_prot.Type_class.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_read_uids : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Read_ml.html#TYPEreader">Core.Std.Bin_prot.Read_ml.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_read_uids_ : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Unsafe_read_c.html#TYPEreader">Core.Std.Bin_prot.Unsafe_read_c.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_read_uids__ : <code class="type">(int -&gt; <a href="Extended_linux.html#TYPEuids">uids</a>) <a href="../core/Std.Bin_prot.Unsafe_read_c.html#TYPEreader">Core.Std.Bin_prot.Unsafe_read_c.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_reader_uids : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Type_class.html#TYPEreader">Core.Std.Bin_prot.Type_class.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_size_uids : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Size.html#TYPEsizer">Core.Std.Bin_prot.Size.sizer</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_write_uids : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Write_ml.html#TYPEwriter">Core.Std.Bin_prot.Write_ml.writer</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_write_uids_ : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Unsafe_write_c.html#TYPEwriter">Core.Std.Bin_prot.Unsafe_write_c.writer</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_writer_uids : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> <a href="../core/Std.Bin_prot.Type_class.html#TYPEwriter">Core.Std.Bin_prot.Type_class.writer</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> uids_of_sexp : <code class="type"><a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a> -&gt; <a href="Extended_linux.html#TYPEuids">uids</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> sexp_of_uids : <code class="type"><a href="Extended_linux.html#TYPEuids">uids</a> -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a></code></span></pre>
      
    
<br/><br/><h6 id="6_TITLE">Splicing - zero-copies between kernel buffers</h6><br/> <br/>
	  
<br/><br/><h6 id="6_TITLE">Splice flags</h6><br/> <br/>
	  
<br/>Type of Splice event flag<br/>
	  
<br/>Type of Splice event flags<br/>
	  
<br/><code class="code">make_flags ar</code> <b>Returns</b> flags constructed from the array of flags <code class="code">ar</code>.<br/>
	  
<br/><br/><h6 id="6_TITLE">Splice functions</h6><br/> <br/>
	  
<br/><code class="code">splice ?assume_fd_is_nonblocking ~fd_in ?off_in ~fd_out ?off_out
      ~len flags</code> see man-page for details.<div class="parameters"><div class="param_info"><code class="code">assume_fd_is_nonblocking</code> : default = false</div><div class="param_info"><code class="code">off_in</code> : default = 0</div><div class="param_info"><code class="code">off_out</code> : default = 0</div></div><b>Raises</b> <code>Unix_error</code> on Unix-errors.<br/><code>Invalid_argument</code> if the offsets or length are invalid<br/> <br/><b>Returns</b> the triple <code class="code">(ret,
      ret_off_in, ret_off_out)</code>, where <code class="code">ret</code> corresponds to the return
      value of the system call, <code class="code">ret_off_in</code> to the final input offset,
      and <code class="code">ret_off_out</code> to the final output offset.<br/> <br/>
	  
<br/><code class="code">tee ?assume_fd_is_nonblocking ~fd_in ~fd_out len flags</code> see man-page
      for details.<br/> <div class="parameters"><div class="param_info"><code class="code">assume_fd_is_nonblocking</code> : default = false</div></div><b>Raises</b> <code>Unix_error</code> on Unix-errors.<br/><code>Invalid_argument</code> if the length is invalid<br/> <br/><br/>
	  
<br/><code class="code">vmsplice ?assume_fd_is_nonblocking fd iovecs ?count flags</code>
      see man-page for details.<br/> <div class="parameters"><div class="param_info"><code class="code">assume_fd_is_nonblocking</code> : default = false</div><div class="param_info"><code class="code">count</code> : default = <code class="code">Array.length iovecs</code>
</div></div><b>Raises</b> <code>Unix_error</code> on Unix-errors.<br/><code>Invalid_argument</code> if the count is invalid<br/> <br/><br/>
	  

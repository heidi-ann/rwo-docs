<!DOCTYPE HTML>
<html>
<head>

<title>Core_map</title>
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type"/>
<link rel="stylesheet" href="style.css" type="text/css"/>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"> </script>
<script type="text/javascript" src="doc_loader.js"> </script>
</head>
<body>

<h1>Module Core_map</h1>
<pre><span class="keyword">module</span> Core_map</pre><div class="info">This module defines the <code class="code">Map</code> module for <code class="code">Core.Std</code>.  We use &quot;core_map&quot; as the file
    name rather than &quot;map&quot; to avoid conflicts with OCaml's standard map module.  In this
    documentation, we use <code class="code">Map</code> to mean this module, not the OCaml standard one.<br/>    <code class="code">Map</code> is a functional datastructure (balanced binary tree) implementing finite maps
    over a totally-ordered domain, called a &quot;key&quot;.  The map types and operations appear
    in three places:<br/>    <span class="verbatim">    | Map      | polymorphic map operations                                      |
    | Map.Poly | maps that use polymorphic comparison to order keys              |
    | Key.Map  | maps with a fixed key type that use [Key.compare] to order keys |
    </span><br/>    Where <code class="code">Key</code> is any module defining values that can be used as keys of a map, like
    <code class="code">Int</code>, <code class="code">String</code>, ...<br/>    One should use <code class="code">Map</code> for functions that access existing maps, like <code class="code">find</code>, <code class="code">mem</code>,
    <code class="code">add</code>, <code class="code">fold</code>, <code class="code">iter</code>, and <code class="code">to_alist</code>.  For functions that create maps, like <code class="code">empty</code>,
    <code class="code">singleton</code>, and <code class="code">of_alist</code>, one should strive to use the corresponding <code class="code">Key.Map</code>
    function, which will use the comparison function specifically for <code class="code">Key</code>.  As a last
    resort, if one does not have easy access to a comparison function for the keys in
    one's map, use <code class="code">Map.Poly</code> to create the map.  This will use OCaml's built-in
    polymorphic comparison to compare keys, which has all the usual performance and
    robustness problems that entails.<br/>    Parallel to the three kinds of map modules, there are also tree modules <code class="code">Map.Tree</code>,
    <code class="code">Map.Poly.Tree</code>, and <code class="code">Key.Map.Tree</code>.  A tree is a bare representation of a map,
    without the comparator.  Thus tree operations need to obtain the comparator from
    somewhere.  For <code class="code">Map.Poly.Tree</code> and <code class="code">Key.Map.Tree</code>, the comparator is implicit in the
    module name.  For <code class="code">Map.Tree</code>, the comparator must be passed to each operation.  The
    main advantages of trees over maps are slightly improved space usage (there is no
    outer container holding the comparator) and the ability to marshal trees, because a
    tree doesn't contain a closure, unlike a map.  The main disadvantages of using trees
    are needing to be more explicit about the comparator, and the possibility of
    accidental use of polymorphic equality on a tree (for which maps dynamically detect
    failure due to the presence of a closure in the data structure).<br/>    For a detailed explanation of the interface design, read on.<br/>    An instance of the map type is determined by the types of the map's keys and values,
    and the comparison function used to order the keys:<br/>    <pre class="codepre"><code class="code"> type ('key, 'value, 'cmp) Map.t </code></pre><br/>    <code class="code">'cmp</code> is a phantom type uniquely identifying the comparison function, as generated by
    <code class="code">Comparator.Make</code>.<br/>    <code class="code">Map.Poly</code> supports arbitrary key and value types, but enforces that the comparison
    function used to order the keys is polymorphic comparison.  <code class="code">Key.Map</code> has a fixed key
    type and comparison function, and supports arbitrary values.<br/>    <pre class="codepre"><code class="code">
      type ('key, 'value) Map.Poly.t = ('key , 'value, Comparator.Poly.t) Map.t
      type 'value Key.Map.t          = (Key.t, 'value, Key.comparator   ) Map.t
    </code></pre><br/>    The same map operations exist in <code class="code">Map</code>, <code class="code">Map.Poly</code>, and <code class="code">Key.Map</code>, albeit with
    different types.  For example:<br/>    <pre class="codepre"><code class="code">
      val Map.length      : (_, _, _) Map.t   -&gt; int
      val Map.Poly.length : (_, _) Map.Poly.t -&gt; int
      val Key.Map.length  : _ Key.Map.t       -&gt; int
    </code></pre><br/>    Because <code class="code">Map.Poly.t</code> and <code class="code">Key.Map.t</code> are exposed as instances of the more general
    <code class="code">Map.t</code> type, one can use <code class="code">Map.length</code> on any map.  The same is true for all of the
    functions that access an existing map, such as <code class="code">add</code>, <code class="code">change</code>, <code class="code">find</code>, <code class="code">fold</code>,
    <code class="code">iter</code>, <code class="code">map</code>, <code class="code">to_alist</code>, etc.<br/>    Depending on the number of type variables <code class="code">N</code>, the type of accessor (resp. creator)
    functions are defined in the module type <code class="code">AccessorsN</code> (resp. <code class="code">CreatorsN</code>) in
    TODO reference : Core_map_intf.  Also for creators, when the comparison function is not fixed,
    i.e. the <code class="code">'cmp</code> variable of <code class="code">Map.t</code> is free, we need to pass a comparator to the
    function creating the map.  The module type is called <code class="code">Creators3_with_comparator</code>.
    There is also a module type <code class="code">Accessors3_with_comparator</code> in addition to <code class="code">Accessors3</code>
    which used for trees since the comparator is not known.</div>
<hr/>
<div file="Core_map.html.contents" class="content_to_load"> </div>
</body>
</html>
 
      <pre><span><span class="keyword">val</span> escape_gen_exn : <code class="type">escapeworthy_map:(char * char) list -&gt;
escape_char:char -&gt; (string -&gt; string) <a href="Staged.html#TYPEt">Staged.t</a></code></span></pre>
      <div class="info"><code class="code">escape_gen_exn escapeworthy_map escape_char</code> returns a function that will escape a
      string <code class="code">s</code> as follows: if <code class="code">(c1,c2)</code> is in <code class="code">escapeworthy_map</code>, then all occurences of
      <code class="code">c1</code> are replaced by <code class="code">escape_char</code> concatenated to <code class="code">c2</code>.<br/>      Raises an exception if <code class="code">escapeworthy_map</code> is not one-to-one.  If <code class="code">escape_char</code> is
      not in <code class="code">escapeworthy_map</code>, then it will be escaped to itself.</div>
    
 
      <pre><span><span class="keyword">val</span> escape_gen : <code class="type">escapeworthy_map:(char * char) list -&gt;
escape_char:char -&gt; (string -&gt; string) <a href="Or_error.html#TYPEt">Or_error.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> escape : <code class="type">escapeworthy:char list -&gt; escape_char:char -&gt; (string -&gt; string) <a href="Staged.html#TYPEt">Staged.t</a></code></span></pre>
      <div class="info"><code class="code">escape ~escapeworthy ~escape_char s</code> is
      <pre class="codepre"><code class="code">
        escape_gen_exn ~escapeworthy_map:(List.zip_exn escapeworthy escapeworthy)
          ~escape_char
      </code></pre>.
      Duplicates and <code class="code">escape_char</code> will be removed from <code class="code">escapeworthy</code>.  So, no
      exception will be raised</div>
    
 
      <pre><span><span class="keyword">val</span> unescape_gen_exn : <code class="type">escapeworthy_map:(char * char) list -&gt;
escape_char:char -&gt; (string -&gt; string) <a href="Staged.html#TYPEt">Staged.t</a></code></span></pre>
      <div class="info"><code class="code">unescape_gen_exn</code> is the inverse operation of <code class="code">escape_gen_exn</code>. That is,
      <pre class="codepre"><code class="code">
      let escape = Staged.unstage (escape_gen_exn ~escapeworthy_map ~escape_char) in
      let unescape = Staged.unstage (unescape_gen_exn ~escapeworthy_map ~escape_char) in
      assert (s = unescape (escape s))
      </code></pre>
      always succeed when ~escapeworthy_map is not causing exceptions.</div>
    
 
      <pre><span><span class="keyword">val</span> unescape_gen : <code class="type">escapeworthy_map:(char * char) list -&gt;
escape_char:char -&gt; (string -&gt; string) <a href="Or_error.html#TYPEt">Or_error.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> unescape : <code class="type">escape_char:char -&gt; (string -&gt; string) <a href="Staged.html#TYPEt">Staged.t</a></code></span></pre>
      <div class="info"><code class="code">unescape ~escape_char</code> is defined as <code class="code">unescape_gen_exn ~map:[] ~escape_char</code> </div>
    
 
      <pre><span><span class="keyword">val</span> is_char_escaping : <code class="type">string -&gt; escape_char:char -&gt; int -&gt; bool</code></span></pre>
      <div class="info">Any char in an escaped string is either escaping, escaped or literal. For example,
      for escaped string &quot;0_a0__0&quot; with escape_char as '_', pos 1 and 4 are escaping, 2
      and 5 are escaped, and the rest are literal<br/>      <code class="code">is_char_escaping s ~escape_char pos</code> return true if the char at <code class="code">pos</code> is escaping,
      false otherwise.</div>
    
 
      <pre><span><span class="keyword">val</span> is_char_escaped : <code class="type">string -&gt; escape_char:char -&gt; int -&gt; bool</code></span></pre>
      <div class="info"><code class="code">is_char_escaped s ~escape_char pos</code> return true if the char at <code class="code">pos</code> is escaped,
      false otherwise.</div>
    
 
      <pre><span><span class="keyword">val</span> is_char_literal : <code class="type">string -&gt; escape_char:char -&gt; int -&gt; bool</code></span></pre>
      <div class="info"><code class="code">is_literal s ~escape_char pos</code> return true if the char at <code class="code">pos</code> is not escaped or
      escaping.</div>
    
 
      <pre><span><span class="keyword">val</span> index : <code class="type">string -&gt; escape_char:char -&gt; char -&gt; int option</code></span></pre>
      <div class="info"><code class="code">index s ~escape_char char</code> find the first literal (not escaped) instance of
      char in s starting from 0.</div>
    
 
      <pre><span><span class="keyword">val</span> index_exn : <code class="type">string -&gt; escape_char:char -&gt; char -&gt; int</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> rindex : <code class="type">string -&gt; escape_char:char -&gt; char -&gt; int option</code></span></pre>
      <div class="info"><code class="code">rindex s ~escape_char char</code> find the first literal (not escaped) instance of
      char in s starting from the end of s and proceeding towards 0.</div>
    
 
      <pre><span><span class="keyword">val</span> rindex_exn : <code class="type">string -&gt; escape_char:char -&gt; char -&gt; int</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> index_from : <code class="type">string -&gt; escape_char:char -&gt; int -&gt; char -&gt; int option</code></span></pre>
      <div class="info"><code class="code">index_from s ~escape_char pos char</code> find the first literal (not escaped)
      instance of char in s starting from pos and proceeding towards the end of s.</div>
    
 
      <pre><span><span class="keyword">val</span> index_from_exn : <code class="type">string -&gt; escape_char:char -&gt; int -&gt; char -&gt; int</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> rindex_from : <code class="type">string -&gt; escape_char:char -&gt; int -&gt; char -&gt; int option</code></span></pre>
      <div class="info"><code class="code">rindex_from s ~escape_char pos char</code> find the first literal (not escaped)
      instance of char in s starting from pos and towards 0.</div>
    
 
      <pre><span><span class="keyword">val</span> rindex_from_exn : <code class="type">string -&gt; escape_char:char -&gt; int -&gt; char -&gt; int</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> split : <code class="type">string -&gt; on:char -&gt; escape_char:char -&gt; string list</code></span></pre>
      <div class="info"><code class="code">split s ~escape_char ~on</code> <b>Returns</b> a list of substrings of <code class="code">s</code> that are separated by
      literal versions of <code class="code">on</code>.  Consecutive <code class="code">on</code> characters will cause multiple empty
      strings in the result.  Splitting the empty string returns a list of the empty
      string, not the empty list.<br/>      e.g. split ~escape_char:'_' ~on:',' &quot;foo,bar_,baz&quot; = <code class="code">&quot;foo&quot;; &quot;bar_,baz&quot;</code> </div>
    
 
      <pre><span><span class="keyword">val</span> split_on_chars : <code class="type">string -&gt; on:char list -&gt; escape_char:char -&gt; string list</code></span></pre>
      <div class="info"><code class="code">split_on_chars s ~on</code> <b>Returns</b> a list of all substrings of <code class="code">s</code> that are separated by
      one of the literal chars from <code class="code">on</code>.  <code class="code">on</code> are not grouped.  So a grouping of <code class="code">on</code> in
      the source string will produce multiple empty string splits in the result.<br/>      e.g. split_on_chars ~escape_char:'_' ~on:<code class="code">',';'|'</code> &quot;foo_|bar,baz|0&quot; -&gt;
      <code class="code">&quot;foo_|bar&quot;; &quot;baz&quot;; &quot;0&quot;</code> </div>
    
 
      <pre><span><span class="keyword">val</span> lsplit2 : <code class="type">string -&gt; on:char -&gt; escape_char:char -&gt; (string * string) option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> lsplit2_exn : <code class="type">string -&gt; on:char -&gt; escape_char:char -&gt; string * string</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> rsplit2 : <code class="type">string -&gt; on:char -&gt; escape_char:char -&gt; (string * string) option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> rsplit2_exn : <code class="type">string -&gt; on:char -&gt; escape_char:char -&gt; string * string</code></span></pre>
      
    

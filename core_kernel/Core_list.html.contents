<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t </span>= <code class="type">'a list</code> </pre>
      
    
<div class="expanding_content">
	<button onclick="expand_content(this)">-</button>
	<pre><span class="keyword">include</span> <code class="code"><a href="Container.S1.html">Container.S1</a></code> with type t = 'a <a href="Core_list.html#TYPEt">t</a></pre>
	<div class="content">
	<div file="Container.S1.html.contents" class="content_to_load"> </div>
	</div>
  </div>
<div class="expanding_content">
	<button onclick="expand_content(this)">-</button>
	<pre><span class="keyword">include</span> <code class="code"><a href="Monad.S.html">Monad.S</a></code> with type t = 'a <a href="Core_list.html#TYPEt">t</a></pre>
	<div class="content">
	<div file="Monad.S.html.contents" class="content_to_load"> </div>
	</div>
  </div>
 
      <pre><span><span class="keyword">val</span> of_list : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">of_list</code> is the identity function.  It is useful so that the <code class="code">List</code> module matches
    the same signature that other container modules do, namely:<br/>    <pre class="codepre"><code class="code">
      val of_list : 'a List.t -&gt; 'a t
    </code></pre>
</div>
    
 
      <pre><span><span class="keyword">val</span> nth : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; int -&gt; 'a option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> nth_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; int -&gt; 'a</code></span></pre>
      <div class="info">Return the <code class="code">n</code>-th element of the given list.
    The first element (head of the list) is at position 0.
    Raise <code class="code">Failure &quot;nth&quot;</code> if the list is too short.
    Raise <code class="code">Invalid_argument &quot;List.nth&quot;</code> if <code class="code">n</code> is negative.</div>
    
 
      <pre><span><span class="keyword">val</span> rev : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">List reversal.</div>
    
 
      <pre><span><span class="keyword">val</span> rev_append : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">List.rev_append l1 l2</code> reverses <code class="code">l1</code> and concatenates it to <code class="code">l2</code>.  This is equivalent
    to <code class="code">(</code>TODO reference : List.rev<code class="code"> l1) @ l2</code>, but <code class="code">rev_append</code> is more efficient.</div>
    
 
      <pre><span><span class="keyword">val</span> unordered_append : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> rev_map : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">List.rev_map f l</code> gives the same result as
   TODO reference : List.rev<code class="code"> (</code>TODO reference : ListLabels.map<code class="code"> f l)</code>, but is more efficient.</div>
    
 
      <pre><span><span class="keyword">val</span> fold_left : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; init:'b -&gt; f:('b -&gt; 'a -&gt; 'b) -&gt; 'b</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> iter2_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; unit) -&gt; unit</code></span></pre>
      <div class="info"><code class="code">List.iter2_exn f [a1; ...; an] [b1; ...; bn]</code> calls in turn
    <code class="code">f a1 b1; ...; f an bn</code>.
    Raise <code class="code">Invalid_argument</code> if the two lists have
    different lengths.</div>
    
 
      <pre><span><span class="keyword">val</span> rev_map2_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">List.rev_map2_exn f l1 l2</code> gives the same result as
   TODO reference : List.rev<code class="code"> (</code>TODO reference : List.map2_exn<code class="code"> f l1 l2)</code>, but is more efficient.</div>
    
 
      <pre><span><span class="keyword">val</span> fold2_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; init:'c -&gt; f:('c -&gt; 'a -&gt; 'b -&gt; 'c) -&gt; 'c</code></span></pre>
      <div class="info"><code class="code">List.fold2_exn f a [b1; ...; bn] [c1; ...; cn]</code> is
   <code class="code">f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>.
   Raise <code class="code">Invalid_argument</code> if the two lists have
   different lengths.</div>
    
 
      <pre><span><span class="keyword">val</span> for_all2_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; bool) -&gt; bool</code></span></pre>
      <div class="info">Same as TODO reference : List.for_all, but for a two-argument predicate.
   Raise <code class="code">Invalid_argument</code> if the two lists have
   different lengths.</div>
    
 
      <pre><span><span class="keyword">val</span> exists2_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; bool) -&gt; bool</code></span></pre>
      <div class="info">Same as TODO reference : List.exists, but for a two-argument predicate.  Raise
    <code class="code">Invalid_argument</code> if the end of one list is reached before the end of the
    other.</div>
    
 
      <pre><span><span class="keyword">val</span> filter : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">filter p l</code> returns all the elements of the list <code class="code">l</code> that satisfy the predicate <code class="code">p</code>.
    The order of the elements in the input list is preserved.</div>
    
 
      <pre><span><span class="keyword">val</span> rev_filter : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Like <code class="code">filter</code>, but reverses the order of the input list</div>
    
 
      <pre><span><span class="keyword">val</span> filteri : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> partition_map : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; [ `Fst of 'b | `Snd of 'c ]) -&gt; 'b <a href="Core_list.html#TYPEt">t</a> * 'c <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">partition_map t ~f</code> partitions <code class="code">t</code> according to <code class="code">f</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> partition_tf : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> * 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">partition_tf p l</code> returns a pair of lists <code class="code">(l1, l2)</code>, where <code class="code">l1</code> is the list of all the
    elements of <code class="code">l</code> that satisfy the predicate <code class="code">p</code>, and <code class="code">l2</code> is the list of all the
    elements of <code class="code">l</code> that do not satisfy <code class="code">p</code>.  The order of the elements in the input list
    is preserved.  The &quot;tf&quot; suffix is mnemonic to remind readers at a call that the result
    is (trues, falses).</div>
    
 
      <pre><span><span class="keyword">val</span> split_n : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; int -&gt; 'a <a href="Core_list.html#TYPEt">t</a> * 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">split_n n [e1; ...; em]</code> is <code class="code">([e1; ...; en], [en+1; ...; em])</code>.  If <code class="code">n &gt; m</code>,
    <code class="code">([e1; ...; em], [])</code> is returned.  If <code class="code">n &lt; 0</code>, <code class="code">([], [e1; ...; em])</code> is
    returned.</div>
    
 
      <pre><span><span class="keyword">val</span> sort : <code class="type">cmp:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Sort a list in increasing order according to a comparison function.  The comparison
    function must return 0 if its arguments compare as equal, a positive integer if the
    first is greater, and a negative integer if the first is smaller (see Array.sort for a
    complete specification).  For example, TODO reference : Pervasives.compare is a suitable comparison
    function.<br/>    The current implementation uses Merge Sort. It runs in constant heap space and
    logarithmic stack space.<br/>    Presently, the sort is stable, meaning that two equal elements in the input will be in
    the same order in the output.</div>
    
 
      <pre><span><span class="keyword">val</span> stable_sort : <code class="type">cmp:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Same as sort, but guaranteed to be stable</div>
    
 
      <pre><span><span class="keyword">val</span> merge : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; cmp:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Merge two lists: assuming that <code class="code">l1</code> and <code class="code">l2</code> are sorted according to the comparison
    function <code class="code">cmp</code>, <code class="code">merge cmp l1 l2</code> will return a sorted list containting all the
    elements of <code class="code">l1</code> and <code class="code">l2</code>.  If several elements compare equal, the elements of <code class="code">l1</code>
    will be before the elements of <code class="code">l2</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> hd : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> tl : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> hd_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a</code></span></pre>
      <div class="info">Return the first element of the given list. Raise
    <code class="code">Failure &quot;hd&quot;</code> if the list is empty.</div>
    
 
      <pre><span><span class="keyword">val</span> tl_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Return the given list without its first element. Raise <code class="code">Failure &quot;tl&quot;</code> if the list is
    empty.</div>
    
 
      <pre><span><span class="keyword">val</span> findi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; bool) -&gt; (int * 'a) option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> find_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a</code></span></pre>
      <div class="info"><code class="code">find_exn t ~f</code> returns the first element of <code class="code">t</code> that satisfies <code class="code">f</code>.  It raises
    <code class="code">Not_found</code> if there is no such element.</div>
    
<br/><br/><h6 id="6_TITLE">Tail-recursive implementations of standard List operations</h6><br/> <br/>
	  
 
      <pre><span><span class="keyword">val</span> append : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">E.g. <code class="code">append [1; 2] [3; 4; 5]</code> is <code class="code">[1; 2; 3; 4; 5]</code> </div>
    
 
      <pre><span><span class="keyword">val</span> map : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">List.map f [a1; ...; an]</code> applies function <code class="code">f</code> to <code class="code">a1, ..., an</code>, and builds the list
    <code class="code">[f a1; ...; f an]</code> with the results returned by <code class="code">f</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> concat_map : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b <a href="Core_list.html#TYPEt">t</a>) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">concat_map t ~f</code> is <code class="code">concat (map t ~f)</code>, except that there is no guarantee about the
    order in which <code class="code">f</code> is applied to the elements of <code class="code">t</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> concat_mapi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b <a href="Core_list.html#TYPEt">t</a>) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">concat_mapi t ~f</code> is like concat_map, but passes the index as an argument</div>
    
 
      <pre><span><span class="keyword">val</span> map2_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; 'c) -&gt; 'c <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">List.map2_exn f [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[f a1 b1; ...; f an bn]</code>.  Raise
    <code class="code">Invalid_argument</code> if the two lists have different lengths.</div>
    
 
      <pre><span><span class="keyword">val</span> rev_map3_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; 'c <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; 'c -&gt; 'd) -&gt; 'd <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> map3_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; 'c <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; 'c -&gt; 'd) -&gt; 'd <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> rev_map_append : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">rev_map_append ~f l1 l2</code> reverses <code class="code">l1</code> mapping <code class="code">f</code> over each
    element, and appends the result to the front of <code class="code">l2</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> fold_right : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b -&gt; 'b) -&gt; init:'b -&gt; 'b</code></span></pre>
      <div class="info"><code class="code">List.fold_right f [a1; ...; an] b</code> is
    <code class="code">f a1 (f a2 (... (f an b) ...))</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> unzip : <code class="type">('a * 'b) <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> * 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Transform a list of pairs into a pair of lists:
    <code class="code">unzip [(a1,b1); ...; (an,bn)]</code> is <code class="code">([a1; ...; an], [b1; ...; bn])</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> zip : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; ('a * 'b) <a href="Core_list.html#TYPEt">t</a> option</code></span></pre>
      <div class="info">Transform a pair of lists into an (optional) list of pairs:
    <code class="code">zip [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[(a1,b1); ...; (an,bn)]</code>.
    Returns None if the two lists have different lengths.</div>
    
 
      <pre><span><span class="keyword">val</span> zip_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; ('a * 'b) <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> mapi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">mapi is just like map, but it also passes in the index of each
    element as the first argument to the mapped function. Tail-recursive.</div>
    
 
      <pre><span><span class="keyword">val</span> rev_mapi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> iteri : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; unit) -&gt; unit</code></span></pre>
      <div class="info">iteri is just like iter, but it also passes in the index of each
    element as the first argument to the iter'd function. Tail-recursive.</div>
    
 
      <pre><span><span class="keyword">val</span> foldi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'b -&gt; 'a -&gt; 'b) -&gt; init:'b -&gt; 'b</code></span></pre>
      <div class="info">foldi is just like fold, but it also passes in the index of each
    element as the first argument to the folded function.  Tail-recursive.</div>
    
 
      <pre><span><span class="keyword">val</span> reduce_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'a -&gt; 'a) -&gt; 'a</code></span></pre>
      <div class="info"><code class="code">reduce_exn f [a1; ...; an]</code> is <code class="code">f (... (f (f a1 a2) a3) ...) an</code>.
    It fails on the empty list.  Tail recursive.</div>
    
 
      <pre><span><span class="keyword">val</span> reduce : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'a -&gt; 'a) -&gt; 'a option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> group : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; break:('a -&gt; 'a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">group l ~break</code> returns a list of lists (i.e., groups) whose concatenation is
    equal to the original list.  Each group is broken where break returns true on
    a pair of successive elements.<br/>    Example<br/>    group ~break:(&lt;&gt;) <code class="code">'M';'i';'s';'s';'i';'s';'s';'i';'p';'p';'i'</code> -&gt;<br/>    <code class="code">['M'];['i'];['s';'s'];['i'];['s';'s'];['i'];['p';'p'];['i']</code>
</div>
    
 
      <pre><span><span class="keyword">val</span> groupi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; break:(int -&gt; 'a -&gt; 'a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">This is just like group, except that you get the index in the original list of the
    current element along with the two elements.<br/>    Example, group the chars of Mississippi into triples<br/>    groupi ~break:(fun i _ _ -&gt; i mod 3 = 0)
    <code class="code">'M';'i';'s';'s';'i';'s';'s';'i';'p';'p';'i'</code> -&gt;<br/>    <code class="code">['M'; 'i'; 's']; ['s'; 'i'; 's']; ['s'; 'i'; 'p']; ['p'; 'i']</code>
</div>
    
 
      <pre><span><span class="keyword">val</span> last : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a option</code></span></pre>
      <div class="info">The final element of a list.  The _exn version raises Invalid_argument on the empty
    list.</div>
    
 
      <pre><span><span class="keyword">val</span> last_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> remove_consecutive_duplicates : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; equal:('a -&gt; 'a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">remove_consecutive_duplicates</code>. The same list with consecutive duplicates removed.
    The relative order of the other elements is unaffected.</div>
    
 
      <pre><span><span class="keyword">val</span> dedup : <code class="type">?compare:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">dedup</code> (de-duplicate).  The same list with duplicates removed, but the
    order is not guaranteed.</div>
    
 
      <pre><span><span class="keyword">val</span> contains_dup : <code class="type">?compare:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      <div class="info"><code class="code">contains_dup</code> True if there are any two elements in the list which are the same.</div>
    
 
      <pre><span><span class="keyword">val</span> find_a_dup : <code class="type">?compare:('a -&gt; 'a -&gt; int) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a option</code></span></pre>
      <div class="info"><code class="code">find_a_dup</code> returns a duplicate from the list (no guarantees about which
    duplicate you get), or None if there are no dups.</div>
    
<pre><span id="EXCEPTIONDuplicate_found"><span class="keyword">exception</span> Duplicate_found</span> <span class="keyword">of</span> <code class="type">unit -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a> * string</code></pre>
 
      <pre><span><span class="keyword">val</span> exn_if_dup : <code class="type">?compare:('a -&gt; 'a -&gt; int) -&gt;
?context:string -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; to_sexp:('a -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a>) -&gt; unit</code></span></pre>
      <div class="info"><code class="code">exn_if_dup ?compare ?context t ~to_sexp</code> will run <code class="code">find_a_dup</code> on <code class="code">t</code>, and raise
    <code class="code">Duplicate_found</code> if a duplicate is found.  The <code class="code">context</code> is the second argument of
    the exception</div>
    
 
      <pre><span><span class="keyword">val</span> count : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; int</code></span></pre>
      <div class="info"><code class="code">count f l</code> is the number of elements in <code class="code">l</code> that satisfy the
    predicate <code class="code">f</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> range : <code class="type">?stride:int -&gt;
?start:[ `exclusive | `inclusive ] -&gt;
?stop:[ `exclusive | `inclusive ] -&gt; int -&gt; int -&gt; int <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">range ?stride ?start ?stop start_i stop_i</code> is the list of integers from <code class="code">start_i</code> to
    <code class="code">stop_i</code>, stepping by <code class="code">stride</code>.  If <code class="code">stride</code> &lt; 0 then we need <code class="code">start_i</code> &gt; <code class="code">stop_i</code> for
    the result to be nonempty (or <code class="code">start_i</code> = <code class="code">stop_i</code> in the case where both bounds are
    inclusive).</div>
    
 
      <pre><span><span class="keyword">val</span> init : <code class="type">int -&gt; f:(int -&gt; 'a) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">init f n</code> is <code class="code">[(f 0); (f 1); ...; (f (n-1))]</code>. It is an error if <code class="code">n &lt; 0</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> rev_filter_map : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b option) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">rev_filter_map f l</code> is the reversed sublist of <code class="code">l</code> containing
    only elements for which <code class="code">f</code> returns <code class="code">Some e</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> rev_filter_mapi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b option) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">rev_filter_mapi is just like rev_filter_map, but it also passes in the index of each
    element as the first argument to the mapped function. Tail-recursive.</div>
    
 
      <pre><span><span class="keyword">val</span> filter_map : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; 'b option) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">filter_map f l</code> is the sublist of <code class="code">l</code> containing only elements
    for which <code class="code">f</code> returns <code class="code">Some e</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> filter_mapi : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:(int -&gt; 'a -&gt; 'b option) -&gt; 'b <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">filter_mapi is just like filter_map, but it also passes in the index of each
    element as the first argument to the mapped function. Tail-recursive.</div>
    
 
      <pre><span><span class="keyword">val</span> filter_opt : <code class="type">'a option <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">filter_opt l</code> is the sublist of <code class="code">l</code> containing only elements
    which are <code class="code">Some e</code>.  In other words, <code class="code">filter_opt l</code> = <code class="code">filter_map ~f:ident l</code>.</div>
    
<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Core_list.Assoc.html">Assoc</a> : <code class="code">sig</code> <a href="Core_list.Assoc.html">..</a> <code class="code">end</code></pre>
	<div class="content" style="display:none">
	<div file="Core_list.Assoc.html.contents" class="content_to_load"> </div>
	</div>
  </div>
<br/>Note that <code class="code">sub</code>, unlike <code class="code">slice</code>, doesn't use python-style indices!<br/>
	  
 
      <pre><span><span class="keyword">val</span> sub : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; pos:int -&gt; len:int -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">sub pos len l</code> is the <code class="code">len</code>-element sublist of <code class="code">l</code>, starting at <code class="code">pos</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> slice : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; int -&gt; int -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">slice l start stop</code> returns a new list including elements <code class="code">l.(start)</code> through
    <code class="code">l.(stop-1)</code>, normalized python-style.</div>
    
 
      <pre><span><span class="keyword">val</span> take : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; int -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">take l n</code> is <code class="code">fst (split_n n l)</code>.
    <code class="code">drop l n</code> is <code class="code">snd (split_n n l)</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> drop : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; int -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> take_while : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">take_while l ~f</code> returns the longest prefix of <code class="code">l</code> for which <code class="code">f</code> is <code class="code">true</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> drop_while : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">drop_while l ~f</code> drops the longest prefix of <code class="code">l</code> for which <code class="code">f</code> is <code class="code">true</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> split_while : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; f:('a -&gt; bool) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> * 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">split_while xs ~f = (take_while xs ~f, drop_while xs ~f)</code> </div>
    
 
      <pre><span><span class="keyword">val</span> concat : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Concatenate a list of lists.  The elements of the argument are all concatenated
    together (in the same order) to give the result.  Tail recursive over outer and inner
    lists.</div>
    
 
      <pre><span><span class="keyword">val</span> concat_no_order : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info">Same as <code class="code">concat</code> but faster and without preserving any ordering (ie for lists that are
    essentially viewed as multi-sets.</div>
    
 
      <pre><span><span class="keyword">val</span> cons : <code class="type">'a -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> cartesian_product : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'b <a href="Core_list.html#TYPEt">t</a> -&gt; ('a * 'b) <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> to_string : <code class="type">f:('a -&gt; string) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; string</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> permute : <code class="type">?random_state:<a href="Core_random.State.html#TYPEt">Core_random.State.t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">permute ?random_state t</code> returns a permutation of <code class="code">t</code>.<br/>    <code class="code">permute</code> side affects <code class="code">random_state</code> by repeated calls to <code class="code">Random.State.int</code>.
    If <code class="code">random_state</code> is not supplied, <code class="code">permute</code> uses <code class="code">Random.State.default</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> is_sorted : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; compare:('a -&gt; 'a -&gt; int) -&gt; bool</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> compare : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; cmp:('a -&gt; 'a -&gt; int) -&gt; int</code></span></pre>
      <div class="info">lexicographic</div>
    
 
      <pre><span><span class="keyword">val</span> equal : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; equal:('a -&gt; 'a -&gt; bool) -&gt; bool</code></span></pre>
      
    
<div class="expanding_content">
	<button onclick="expand_content(this)">+</button><pre><span class="keyword">module</span> <a href="Core_list.Infix.html">Infix</a> : <code class="code">sig</code> <a href="Core_list.Infix.html">..</a> <code class="code">end</code></pre>
	<div class="content" style="display:none">
	<div file="Core_list.Infix.html.contents" class="content_to_load"> </div>
	</div>
  </div>
 
      <pre><span><span class="keyword">val</span> transpose : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a> option</code></span></pre>
      <div class="info"><code class="code">transpose m</code> transposes the rows and columns of the matrix <code class="code">m</code>,
    considered as either a row of column lists or (dually) a column of row lists.<br/>    Example,<br/>    transpose <code class="code">[1;2;3];[4;5;6]</code> = <code class="code">[1;4];[2;5];[3;6]</code><br/>    On non-empty rectangular matrices, <code class="code">transpose</code> is an involution
    (i.e., <code class="code">transpose (transpose m) = m</code>).  Transpose returns None when called
    on lists of lists with non-uniform lengths.</div>
    
 
      <pre><span><span class="keyword">val</span> transpose_exn : <code class="type">'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">transpose_exn</code> transposes the rows and columns of its argument, throwing exception if
    the list is not rectangular.</div>
    
 
      <pre><span><span class="keyword">val</span> intersperse : <code class="type">'a list -&gt; sep:'a -&gt; 'a list</code></span></pre>
      <div class="info"><code class="code">intersperse xs ~sep</code> places <code class="code">sep</code> between adjacent elements of <code class="code">xs</code>.
    e.g. <code class="code">intersperse [1;2;3] ~sep:0 = [1;0;2;0;3]</code> </div>
    
 
      <pre><span><span class="keyword">val</span> t_of_sexp : <code class="type">(<a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a> -&gt; 'a) -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> sexp_of_t : <code class="type">('a -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a>) -&gt; 'a <a href="Core_list.html#TYPEt">t</a> -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_t : <code class="type">'a <a href="../bin_prot/Type_class.html#TYPEt">Bin_prot.Type_class.t</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Type_class.html#TYPEt">Bin_prot.Type_class.t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_read_t : <code class="type">'a <a href="../bin_prot/Unsafe_read_c.html#TYPEreader">Bin_prot.Unsafe_read_c.reader</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Read_ml.html#TYPEreader">Bin_prot.Read_ml.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_read_t_ : <code class="type">'a <a href="../bin_prot/Unsafe_read_c.html#TYPEreader">Bin_prot.Unsafe_read_c.reader</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Unsafe_read_c.html#TYPEreader">Bin_prot.Unsafe_read_c.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_read_t__ : <code class="type">'a <a href="../bin_prot/Unsafe_read_c.html#TYPEreader">Bin_prot.Unsafe_read_c.reader</a> -&gt;
(int -&gt; 'a <a href="Core_list.html#TYPEt">t</a>) <a href="../bin_prot/Unsafe_read_c.html#TYPEreader">Bin_prot.Unsafe_read_c.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_reader_t : <code class="type">'a <a href="../bin_prot/Type_class.html#TYPEreader">Bin_prot.Type_class.reader</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Type_class.html#TYPEreader">Bin_prot.Type_class.reader</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_size_t : <code class="type">'a <a href="../bin_prot/Size.html#TYPEsizer">Bin_prot.Size.sizer</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Size.html#TYPEsizer">Bin_prot.Size.sizer</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_write_t : <code class="type">'a <a href="../bin_prot/Unsafe_write_c.html#TYPEwriter">Bin_prot.Unsafe_write_c.writer</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Write_ml.html#TYPEwriter">Bin_prot.Write_ml.writer</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_write_t_ : <code class="type">'a <a href="../bin_prot/Unsafe_write_c.html#TYPEwriter">Bin_prot.Unsafe_write_c.writer</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Unsafe_write_c.html#TYPEwriter">Bin_prot.Unsafe_write_c.writer</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bin_writer_t : <code class="type">'a <a href="../bin_prot/Type_class.html#TYPEwriter">Bin_prot.Type_class.writer</a> -&gt; 'a <a href="Core_list.html#TYPEt">t</a> <a href="../bin_prot/Type_class.html#TYPEwriter">Bin_prot.Type_class.writer</a></code></span></pre>
      
    
<br/><code class="code">of_list</code> is the identity function.  It is useful so that the <code class="code">List</code> module matches
    the same signature that other container modules do, namely:<br/>    <pre class="codepre"><code class="code">
      val of_list : 'a List.t -&gt; 'a t
    </code></pre>
<br/>
	  
<br/>Return the <code class="code">n</code>-th element of the given list.
    The first element (head of the list) is at position 0.
    Raise <code class="code">Failure &quot;nth&quot;</code> if the list is too short.
    Raise <code class="code">Invalid_argument &quot;List.nth&quot;</code> if <code class="code">n</code> is negative.<br/>
	  
<br/>List reversal.<br/>
	  
<br/><code class="code">List.rev_append l1 l2</code> reverses <code class="code">l1</code> and concatenates it to <code class="code">l2</code>.  This is equivalent
    to <code class="code">(</code>TODO reference : List.rev<code class="code"> l1) @ l2</code>, but <code class="code">rev_append</code> is more efficient.<br/>
	  
<br/><code class="code">List.rev_map f l</code> gives the same result as
   TODO reference : List.rev<code class="code"> (</code>TODO reference : ListLabels.map<code class="code"> f l)</code>, but is more efficient.<br/>
	  
<br/><code class="code">List.iter2_exn f [a1; ...; an] [b1; ...; bn]</code> calls in turn
    <code class="code">f a1 b1; ...; f an bn</code>.
    Raise <code class="code">Invalid_argument</code> if the two lists have
    different lengths.<br/>
	  
<br/><code class="code">List.rev_map2_exn f l1 l2</code> gives the same result as
   TODO reference : List.rev<code class="code"> (</code>TODO reference : List.map2_exn<code class="code"> f l1 l2)</code>, but is more efficient.<br/>
	  
<br/><code class="code">List.fold2_exn f a [b1; ...; bn] [c1; ...; cn]</code> is
   <code class="code">f (... (f (f a b1 c1) b2 c2) ...) bn cn</code>.
   Raise <code class="code">Invalid_argument</code> if the two lists have
   different lengths.<br/>
	  
<br/>Same as TODO reference : List.for_all, but for a two-argument predicate.
   Raise <code class="code">Invalid_argument</code> if the two lists have
   different lengths.<br/>
	  
<br/>Same as TODO reference : List.exists, but for a two-argument predicate.  Raise
    <code class="code">Invalid_argument</code> if the end of one list is reached before the end of the
    other.<br/>
	  
<br/><code class="code">filter p l</code> returns all the elements of the list <code class="code">l</code> that satisfy the predicate <code class="code">p</code>.
    The order of the elements in the input list is preserved.<br/>
	  
<br/>Like <code class="code">filter</code>, but reverses the order of the input list<br/>
	  
<br/><code class="code">partition_map t ~f</code> partitions <code class="code">t</code> according to <code class="code">f</code>.<br/>
	  
<br/><code class="code">partition_tf p l</code> returns a pair of lists <code class="code">(l1, l2)</code>, where <code class="code">l1</code> is the list of all the
    elements of <code class="code">l</code> that satisfy the predicate <code class="code">p</code>, and <code class="code">l2</code> is the list of all the
    elements of <code class="code">l</code> that do not satisfy <code class="code">p</code>.  The order of the elements in the input list
    is preserved.  The &quot;tf&quot; suffix is mnemonic to remind readers at a call that the result
    is (trues, falses).<br/>
	  
<br/><code class="code">split_n n [e1; ...; em]</code> is <code class="code">([e1; ...; en], [en+1; ...; em])</code>.  If <code class="code">n &gt; m</code>,
    <code class="code">([e1; ...; em], [])</code> is returned.  If <code class="code">n &lt; 0</code>, <code class="code">([], [e1; ...; em])</code> is
    returned.<br/>
	  
<br/>Sort a list in increasing order according to a comparison function.  The comparison
    function must return 0 if its arguments compare as equal, a positive integer if the
    first is greater, and a negative integer if the first is smaller (see Array.sort for a
    complete specification).  For example, TODO reference : Pervasives.compare is a suitable comparison
    function.<br/>    The current implementation uses Merge Sort. It runs in constant heap space and
    logarithmic stack space.<br/>    Presently, the sort is stable, meaning that two equal elements in the input will be in
    the same order in the output.<br/>
	  
<br/>Same as sort, but guaranteed to be stable<br/>
	  
<br/>Merge two lists: assuming that <code class="code">l1</code> and <code class="code">l2</code> are sorted according to the comparison
    function <code class="code">cmp</code>, <code class="code">merge cmp l1 l2</code> will return a sorted list containting all the
    elements of <code class="code">l1</code> and <code class="code">l2</code>.  If several elements compare equal, the elements of <code class="code">l1</code>
    will be before the elements of <code class="code">l2</code>.<br/>
	  
<br/>Return the first element of the given list. Raise
    <code class="code">Failure &quot;hd&quot;</code> if the list is empty.<br/>
	  
<br/>Return the given list without its first element. Raise <code class="code">Failure &quot;tl&quot;</code> if the list is
    empty.<br/>
	  
<br/><code class="code">find_exn t ~f</code> returns the first element of <code class="code">t</code> that satisfies <code class="code">f</code>.  It raises
    <code class="code">Not_found</code> if there is no such element.<br/>
	  
<br/><br/><h6 id="6_TITLE">Tail-recursive implementations of standard List operations</h6><br/> <br/>
	  
<br/>E.g. <code class="code">append [1; 2] [3; 4; 5]</code> is <code class="code">[1; 2; 3; 4; 5]</code> <br/>
	  
<br/><code class="code">List.map f [a1; ...; an]</code> applies function <code class="code">f</code> to <code class="code">a1, ..., an</code>, and builds the list
    <code class="code">[f a1; ...; f an]</code> with the results returned by <code class="code">f</code>.<br/>
	  
<br/><code class="code">concat_map t ~f</code> is <code class="code">concat (map t ~f)</code>, except that there is no guarantee about the
    order in which <code class="code">f</code> is applied to the elements of <code class="code">t</code>.<br/>
	  
<br/><code class="code">concat_mapi t ~f</code> is like concat_map, but passes the index as an argument<br/>
	  
<br/><code class="code">List.map2_exn f [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[f a1 b1; ...; f an bn]</code>.  Raise
    <code class="code">Invalid_argument</code> if the two lists have different lengths.<br/>
	  
<br/><code class="code">rev_map_append ~f l1 l2</code> reverses <code class="code">l1</code> mapping <code class="code">f</code> over each
    element, and appends the result to the front of <code class="code">l2</code>.<br/>
	  
<br/><code class="code">List.fold_right f [a1; ...; an] b</code> is
    <code class="code">f a1 (f a2 (... (f an b) ...))</code>.<br/>
	  
<br/>Transform a list of pairs into a pair of lists:
    <code class="code">unzip [(a1,b1); ...; (an,bn)]</code> is <code class="code">([a1; ...; an], [b1; ...; bn])</code>.<br/>
	  
<br/>Transform a pair of lists into an (optional) list of pairs:
    <code class="code">zip [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[(a1,b1); ...; (an,bn)]</code>.
    Returns None if the two lists have different lengths.<br/>
	  
<br/>mapi is just like map, but it also passes in the index of each
    element as the first argument to the mapped function. Tail-recursive.<br/>
	  
<br/>iteri is just like iter, but it also passes in the index of each
    element as the first argument to the iter'd function. Tail-recursive.<br/>
	  
<br/>foldi is just like fold, but it also passes in the index of each
    element as the first argument to the folded function.  Tail-recursive.<br/>
	  
<br/><code class="code">reduce_exn f [a1; ...; an]</code> is <code class="code">f (... (f (f a1 a2) a3) ...) an</code>.
    It fails on the empty list.  Tail recursive.<br/>
	  
<br/><code class="code">group l ~break</code> returns a list of lists (i.e., groups) whose concatenation is
    equal to the original list.  Each group is broken where break returns true on
    a pair of successive elements.<br/>    Example<br/>    group ~break:(&lt;&gt;) <code class="code">'M';'i';'s';'s';'i';'s';'s';'i';'p';'p';'i'</code> -&gt;<br/>    <code class="code">['M'];['i'];['s';'s'];['i'];['s';'s'];['i'];['p';'p'];['i']</code>
<br/>
	  
<br/>This is just like group, except that you get the index in the original list of the
    current element along with the two elements.<br/>    Example, group the chars of Mississippi into triples<br/>    groupi ~break:(fun i _ _ -&gt; i mod 3 = 0)
    <code class="code">'M';'i';'s';'s';'i';'s';'s';'i';'p';'p';'i'</code> -&gt;<br/>    <code class="code">['M'; 'i'; 's']; ['s'; 'i'; 's']; ['s'; 'i'; 'p']; ['p'; 'i']</code>
<br/>
	  
<br/>The final element of a list.  The _exn version raises Invalid_argument on the empty
    list.<br/>
	  
<br/><code class="code">remove_consecutive_duplicates</code>. The same list with consecutive duplicates removed.
    The relative order of the other elements is unaffected.<br/>
	  
<br/><code class="code">dedup</code> (de-duplicate).  The same list with duplicates removed, but the
    order is not guaranteed.<br/>
	  
<br/><code class="code">contains_dup</code> True if there are any two elements in the list which are the same.<br/>
	  
<br/><code class="code">find_a_dup</code> returns a duplicate from the list (no guarantees about which
    duplicate you get), or None if there are no dups.<br/>
	  
<br/><code class="code">exn_if_dup ?compare ?context t ~to_sexp</code> will run <code class="code">find_a_dup</code> on <code class="code">t</code>, and raise
    <code class="code">Duplicate_found</code> if a duplicate is found.  The <code class="code">context</code> is the second argument of
    the exception<br/>
	  
<br/><code class="code">count f l</code> is the number of elements in <code class="code">l</code> that satisfy the
    predicate <code class="code">f</code>.<br/>
	  
<br/><code class="code">range ?stride ?start ?stop start_i stop_i</code> is the list of integers from <code class="code">start_i</code> to
    <code class="code">stop_i</code>, stepping by <code class="code">stride</code>.  If <code class="code">stride</code> &lt; 0 then we need <code class="code">start_i</code> &gt; <code class="code">stop_i</code> for
    the result to be nonempty (or <code class="code">start_i</code> = <code class="code">stop_i</code> in the case where both bounds are
    inclusive).<br/>
	  
<br/><code class="code">init f n</code> is <code class="code">[(f 0); (f 1); ...; (f (n-1))]</code>. It is an error if <code class="code">n &lt; 0</code>.<br/>
	  
<br/><code class="code">rev_filter_map f l</code> is the reversed sublist of <code class="code">l</code> containing
    only elements for which <code class="code">f</code> returns <code class="code">Some e</code>.<br/>
	  
<br/>rev_filter_mapi is just like rev_filter_map, but it also passes in the index of each
    element as the first argument to the mapped function. Tail-recursive.<br/>
	  
<br/><code class="code">filter_map f l</code> is the sublist of <code class="code">l</code> containing only elements
    for which <code class="code">f</code> returns <code class="code">Some e</code>.<br/>
	  
<br/>filter_mapi is just like filter_map, but it also passes in the index of each
    element as the first argument to the mapped function. Tail-recursive.<br/>
	  
<br/><code class="code">filter_opt l</code> is the sublist of <code class="code">l</code> containing only elements
    which are <code class="code">Some e</code>.  In other words, <code class="code">filter_opt l</code> = <code class="code">filter_map ~f:ident l</code>.<br/>
	  
<br/>Note that <code class="code">sub</code>, unlike <code class="code">slice</code>, doesn't use python-style indices!<br/>
	  
<br/><code class="code">sub pos len l</code> is the <code class="code">len</code>-element sublist of <code class="code">l</code>, starting at <code class="code">pos</code>.<br/>
	  
<br/><code class="code">slice l start stop</code> returns a new list including elements <code class="code">l.(start)</code> through
    <code class="code">l.(stop-1)</code>, normalized python-style.<br/>
	  
<br/><code class="code">take l n</code> is <code class="code">fst (split_n n l)</code>.
    <code class="code">drop l n</code> is <code class="code">snd (split_n n l)</code>.<br/>
	  
<br/><code class="code">take_while l ~f</code> returns the longest prefix of <code class="code">l</code> for which <code class="code">f</code> is <code class="code">true</code>.<br/>
	  
<br/><code class="code">drop_while l ~f</code> drops the longest prefix of <code class="code">l</code> for which <code class="code">f</code> is <code class="code">true</code>.<br/>
	  
<br/><code class="code">split_while xs ~f = (take_while xs ~f, drop_while xs ~f)</code> <br/>
	  
<br/>Concatenate a list of lists.  The elements of the argument are all concatenated
    together (in the same order) to give the result.  Tail recursive over outer and inner
    lists.<br/>
	  
<br/>Same as <code class="code">concat</code> but faster and without preserving any ordering (ie for lists that are
    essentially viewed as multi-sets.<br/>
	  
<br/><code class="code">permute ?random_state t</code> returns a permutation of <code class="code">t</code>.<br/>    <code class="code">permute</code> side affects <code class="code">random_state</code> by repeated calls to <code class="code">Random.State.int</code>.
    If <code class="code">random_state</code> is not supplied, <code class="code">permute</code> uses <code class="code">Random.State.default</code>.<br/>
	  
<br/>lexicographic<br/>
	  
<br/><code class="code">transpose m</code> transposes the rows and columns of the matrix <code class="code">m</code>,
    considered as either a row of column lists or (dually) a column of row lists.<br/>    Example,<br/>    transpose <code class="code">[1;2;3];[4;5;6]</code> = <code class="code">[1;4];[2;5];[3;6]</code><br/>    On non-empty rectangular matrices, <code class="code">transpose</code> is an involution
    (i.e., <code class="code">transpose (transpose m) = m</code>).  Transpose returns None when called
    on lists of lists with non-uniform lengths.<br/>
	  
<br/><code class="code">transpose_exn</code> transposes the rows and columns of its argument, throwing exception if
    the list is not rectangular.<br/>
	  
<br/><code class="code">intersperse xs ~sep</code> places <code class="code">sep</code> between adjacent elements of <code class="code">xs</code>.
    e.g. <code class="code">intersperse [1;2;3] ~sep:0 = [1;0;2;0;3]</code> <br/>
	  

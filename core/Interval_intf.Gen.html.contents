<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a </code>t </span></pre>
      
    
<pre><span id="TYPEbound"><span class="keyword">type</span> <code class="type">'a </code>bound </span></pre>
      
    
<br/>Module for simple closed intervals over arbitrary types that are ordered correctly
      using polymorphic compare.<br/>
	  
 
      <pre><span><span class="keyword">val</span> create : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">create l u</code> returns the interval with lower bound <code class="code">l</code> and upper bound <code class="code">u</code>, unless
      <code class="code">l &gt; u</code>, in which case <code class="code">create</code> returns the empty interval.</div>
    
 
      <pre><span><span class="keyword">val</span> empty : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> intersect : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEt">t</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> is_empty : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> is_empty_or_singleton : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bounds : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; ('a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> * 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a>) option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> lbound : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> ubound : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> option</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bounds_exn : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> * 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> lbound_exn : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> ubound_exn : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a></code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> contains : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> -&gt; bool</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> compare_value : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> -&gt; [ `Above | `Below | `Interval_is_empty | `Within ]</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> bound : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> -&gt; 'a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> option</code></span></pre>
      <div class="info"><code class="code">bound t x</code> returns <code class="code">None</code> iff <code class="code">is_empty t</code>.  If <code class="code">bounds t = Some (a, b)</code>, then
      <code class="code">bound</code> returns <code class="code">Some y</code> where <code class="code">y</code> is the element of <code class="code">t</code> closest to <code class="code">x</code>.  I.e.:<br/>      |  y = a  if x &lt; a
      |  y = x  if a &lt;= x &lt;= b
      |  y = b  if x &gt; b</div>
    
 
      <pre><span><span class="keyword">val</span> is_superset : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; of_:'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      <div class="info"><code class="code">is_superset i1 of_:i2</code> is whether i1 contains i2.  The empty interval is
      contained in every interval.</div>
    
 
      <pre><span><span class="keyword">val</span> is_subset : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; of_:'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> map : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> -&gt; f:('a <a href="Interval_intf.Gen.html#TYPEbound">bound</a> -&gt; 'b <a href="Interval_intf.Gen.html#TYPEbound">bound</a>) -&gt; 'b <a href="Interval_intf.Gen.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">map t ~f</code> returns <code class="code">create (f l) (f u)</code> if <code class="code">bounds t = Some (l, u)</code>, and <code class="code">empty</code> if
      <code class="code">t</code> is empty.  Note that if <code class="code">f l &gt; f u</code>, the result of <code class="code">map</code> is <code class="code">empty</code>, by the
      definition of <code class="code">create</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> are_disjoint : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> list -&gt; bool</code></span></pre>
      <div class="info">Returns true iff a given set of intervals are disjoint</div>
    
 
      <pre><span><span class="keyword">val</span> are_disjoint_as_open_intervals : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> list -&gt; bool</code></span></pre>
      <div class="info">Returns true iff a given set of intervals would be disjoint if considered as open
      intervals.  i.e.,  (3,4) and (4,5) would count as disjoint.</div>
    
 
      <pre><span><span class="keyword">val</span> list_intersect : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> list -&gt; 'a <a href="Interval_intf.Gen.html#TYPEt">t</a> list -&gt; 'a <a href="Interval_intf.Gen.html#TYPEt">t</a> list</code></span></pre>
      <div class="info">Assuming that <code class="code">ilist1</code> and <code class="code">ilist2</code> are lists of (disjoint) intervals,
      <code class="code">list_intersect ilist1 ilist2</code> returns the list of disjoint intervals that correspond
      to the intersection of <code class="code">ilist1</code> with <code class="code">ilist2</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> half_open_intervals_are_a_partition : <code class="type">'a <a href="Interval_intf.Gen.html#TYPEt">t</a> list -&gt; bool</code></span></pre>
      
    

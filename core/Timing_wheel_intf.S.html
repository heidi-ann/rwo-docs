<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Timing_wheel_intf.Timing_wheel.html">
<link rel="Up" href="Timing_wheel_intf.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Array_permute" rel="Chapter" href="Array_permute.html">
<link title="Avltree" rel="Chapter" href="Avltree.html">
<link title="Backtrace" rel="Chapter" href="Backtrace.html">
<link title="Bag" rel="Chapter" href="Bag.html">
<link title="Bigbuffer" rel="Chapter" href="Bigbuffer.html">
<link title="Bigbuffer_internal" rel="Chapter" href="Bigbuffer_internal.html">
<link title="Bigstring" rel="Chapter" href="Bigstring.html">
<link title="Bigstring_marshal" rel="Chapter" href="Bigstring_marshal.html">
<link title="Bigsubstring" rel="Chapter" href="Bigsubstring.html">
<link title="Binable" rel="Chapter" href="Binable.html">
<link title="Binable0" rel="Chapter" href="Binable0.html">
<link title="Binary_packing" rel="Chapter" href="Binary_packing.html">
<link title="Blang" rel="Chapter" href="Blang.html">
<link title="Bool" rel="Chapter" href="Bool.html">
<link title="Bounded_int_table" rel="Chapter" href="Bounded_int_table.html">
<link title="Bucket" rel="Chapter" href="Bucket.html">
<link title="Byte_units" rel="Chapter" href="Byte_units.html">
<link title="Caml" rel="Chapter" href="Caml.html">
<link title="Command" rel="Chapter" href="Command.html">
<link title="Common" rel="Chapter" href="Common.html">
<link title="Commutative_group" rel="Chapter" href="Commutative_group.html">
<link title="Comparable" rel="Chapter" href="Comparable.html">
<link title="Comparable_intf" rel="Chapter" href="Comparable_intf.html">
<link title="Comparator" rel="Chapter" href="Comparator.html">
<link title="Constrained_float" rel="Chapter" href="Constrained_float.html">
<link title="Container" rel="Chapter" href="Container.html">
<link title="Core_arg" rel="Chapter" href="Core_arg.html">
<link title="Core_array" rel="Chapter" href="Core_array.html">
<link title="Core_bin_prot" rel="Chapter" href="Core_bin_prot.html">
<link title="Core_char" rel="Chapter" href="Core_char.html">
<link title="Core_condition" rel="Chapter" href="Core_condition.html">
<link title="Core_field" rel="Chapter" href="Core_field.html">
<link title="Core_filename" rel="Chapter" href="Core_filename.html">
<link title="Core_gc" rel="Chapter" href="Core_gc.html">
<link title="Core_hashtbl" rel="Chapter" href="Core_hashtbl.html">
<link title="Core_hashtbl_intf" rel="Chapter" href="Core_hashtbl_intf.html">
<link title="Core_int" rel="Chapter" href="Core_int.html">
<link title="Core_int32" rel="Chapter" href="Core_int32.html">
<link title="Core_int63" rel="Chapter" href="Core_int63.html">
<link title="Core_int64" rel="Chapter" href="Core_int64.html">
<link title="Core_lazy" rel="Chapter" href="Core_lazy.html">
<link title="Core_list" rel="Chapter" href="Core_list.html">
<link title="Core_map" rel="Chapter" href="Core_map.html">
<link title="Core_map_intf" rel="Chapter" href="Core_map_intf.html">
<link title="Core_map_unit_tests" rel="Chapter" href="Core_map_unit_tests.html">
<link title="Core_mutex" rel="Chapter" href="Core_mutex.html">
<link title="Core_nativeint" rel="Chapter" href="Core_nativeint.html">
<link title="Core_printexc" rel="Chapter" href="Core_printexc.html">
<link title="Core_printf" rel="Chapter" href="Core_printf.html">
<link title="Core_queue" rel="Chapter" href="Core_queue.html">
<link title="Core_random" rel="Chapter" href="Core_random.html">
<link title="Core_set" rel="Chapter" href="Core_set.html">
<link title="Core_set_intf" rel="Chapter" href="Core_set_intf.html">
<link title="Core_set_unit_tests" rel="Chapter" href="Core_set_unit_tests.html">
<link title="Core_sexp" rel="Chapter" href="Core_sexp.html">
<link title="Core_stack" rel="Chapter" href="Core_stack.html">
<link title="Core_string" rel="Chapter" href="Core_string.html">
<link title="Core_sys" rel="Chapter" href="Core_sys.html">
<link title="Core_thread" rel="Chapter" href="Core_thread.html">
<link title="Core_unix" rel="Chapter" href="Core_unix.html">
<link title="Core_weak" rel="Chapter" href="Core_weak.html">
<link title="Crc" rel="Chapter" href="Crc.html">
<link title="Daemon" rel="Chapter" href="Daemon.html">
<link title="Date" rel="Chapter" href="Date.html">
<link title="Day_of_week" rel="Chapter" href="Day_of_week.html">
<link title="Dequeue" rel="Chapter" href="Dequeue.html">
<link title="Doubly_linked" rel="Chapter" href="Doubly_linked.html">
<link title="Equal" rel="Chapter" href="Equal.html">
<link title="Error" rel="Chapter" href="Error.html">
<link title="Exn" rel="Chapter" href="Exn.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="Flags_intf" rel="Chapter" href="Flags_intf.html">
<link title="Float" rel="Chapter" href="Float.html">
<link title="Floatable" rel="Chapter" href="Floatable.html">
<link title="Float_intf" rel="Chapter" href="Float_intf.html">
<link title="Float_robust_compare" rel="Chapter" href="Float_robust_compare.html">
<link title="Fn" rel="Chapter" href="Fn.html">
<link title="Force_once" rel="Chapter" href="Force_once.html">
<link title="Fqueue" rel="Chapter" href="Fqueue.html">
<link title="Hashable" rel="Chapter" href="Hashable.html">
<link title="Hash_heap" rel="Chapter" href="Hash_heap.html">
<link title="Hash_queue" rel="Chapter" href="Hash_queue.html">
<link title="Hash_set" rel="Chapter" href="Hash_set.html">
<link title="Hash_set_intf" rel="Chapter" href="Hash_set_intf.html">
<link title="Heap" rel="Chapter" href="Heap.html">
<link title="Heap_block" rel="Chapter" href="Heap_block.html">
<link title="Host_and_port" rel="Chapter" href="Host_and_port.html">
<link title="Identifiable" rel="Chapter" href="Identifiable.html">
<link title="In_channel" rel="Chapter" href="In_channel.html">
<link title="Info" rel="Chapter" href="Info.html">
<link title="Intable" rel="Chapter" href="Intable.html">
<link title="Int_conversions" rel="Chapter" href="Int_conversions.html">
<link title="Interfaces" rel="Chapter" href="Interfaces.html">
<link title="Interned_string" rel="Chapter" href="Interned_string.html">
<link title="Interval" rel="Chapter" href="Interval.html">
<link title="Interval_intf" rel="Chapter" href="Interval_intf.html">
<link title="Int_intf" rel="Chapter" href="Int_intf.html">
<link title="Int_math" rel="Chapter" href="Int_math.html">
<link title="Int_replace_polymorphic_compare" rel="Chapter" href="Int_replace_polymorphic_compare.html">
<link title="Int_set" rel="Chapter" href="Int_set.html">
<link title="Invariant" rel="Chapter" href="Invariant.html">
<link title="Iobuf" rel="Chapter" href="Iobuf.html">
<link title="Iobuf_debug" rel="Chapter" href="Iobuf_debug.html">
<link title="Iobuf_intf" rel="Chapter" href="Iobuf_intf.html">
<link title="Iobuf_tests" rel="Chapter" href="Iobuf_tests.html">
<link title="Linux_ext" rel="Chapter" href="Linux_ext.html">
<link title="Lock_file" rel="Chapter" href="Lock_file.html">
<link title="Make_substring" rel="Chapter" href="Make_substring.html">
<link title="Memo" rel="Chapter" href="Memo.html">
<link title="Monad" rel="Chapter" href="Monad.html">
<link title="Month" rel="Chapter" href="Month.html">
<link title="Mutex0" rel="Chapter" href="Mutex0.html">
<link title="Nano_mutex" rel="Chapter" href="Nano_mutex.html">
<link title="Never_returns" rel="Chapter" href="Never_returns.html">
<link title="No_polymorphic_compare" rel="Chapter" href="No_polymorphic_compare.html">
<link title="Nothing" rel="Chapter" href="Nothing.html">
<link title="Nothing0" rel="Chapter" href="Nothing0.html">
<link title="Ofday" rel="Chapter" href="Ofday.html">
<link title="Only_in_test" rel="Chapter" href="Only_in_test.html">
<link title="Option" rel="Chapter" href="Option.html">
<link title="Ordered_collection_common" rel="Chapter" href="Ordered_collection_common.html">
<link title="Ordering" rel="Chapter" href="Ordering.html">
<link title="Or_error" rel="Chapter" href="Or_error.html">
<link title="Out_channel" rel="Chapter" href="Out_channel.html">
<link title="Pid" rel="Chapter" href="Pid.html">
<link title="Piecewise_linear" rel="Chapter" href="Piecewise_linear.html">
<link title="Piecewise_linear_intf" rel="Chapter" href="Piecewise_linear_intf.html">
<link title="Polymorphic_compare" rel="Chapter" href="Polymorphic_compare.html">
<link title="Polymorphic_compare_intf" rel="Chapter" href="Polymorphic_compare_intf.html">
<link title="Pretty_printer" rel="Chapter" href="Pretty_printer.html">
<link title="Process_env" rel="Chapter" href="Process_env.html">
<link title="Quickcheck" rel="Chapter" href="Quickcheck.html">
<link title="Ref" rel="Chapter" href="Ref.html">
<link title="Result" rel="Chapter" href="Result.html">
<link title="Robustly_comparable" rel="Chapter" href="Robustly_comparable.html">
<link title="Set_once" rel="Chapter" href="Set_once.html">
<link title="Sexpable" rel="Chapter" href="Sexpable.html">
<link title="Signal" rel="Chapter" href="Signal.html">
<link title="Source_code_position" rel="Chapter" href="Source_code_position.html">
<link title="Source_code_position0" rel="Chapter" href="Source_code_position0.html">
<link title="Span" rel="Chapter" href="Span.html">
<link title="Squeue" rel="Chapter" href="Squeue.html">
<link title="Stable" rel="Chapter" href="Stable.html">
<link title="Stable_containers" rel="Chapter" href="Stable_containers.html">
<link title="Stable_internal" rel="Chapter" href="Stable_internal.html">
<link title="Stable_unit_test" rel="Chapter" href="Stable_unit_test.html">
<link title="Stable_unit_test_intf" rel="Chapter" href="Stable_unit_test_intf.html">
<link title="Staged" rel="Chapter" href="Staged.html">
<link title="Std" rel="Chapter" href="Std.html">
<link title="Std_common" rel="Chapter" href="Std_common.html">
<link title="Std_kernel" rel="Chapter" href="Std_kernel.html">
<link title="Std_internal" rel="Chapter" href="Std_internal.html">
<link title="Stringable" rel="Chapter" href="Stringable.html">
<link title="String_id" rel="Chapter" href="String_id.html">
<link title="Substring" rel="Chapter" href="Substring.html">
<link title="Substring_intf" rel="Chapter" href="Substring_intf.html">
<link title="T" rel="Chapter" href="T.html">
<link title="Thread_safe_queue" rel="Chapter" href="Thread_safe_queue.html">
<link title="Time" rel="Chapter" href="Time.html">
<link title="Time_internal" rel="Chapter" href="Time_internal.html">
<link title="Timer" rel="Chapter" href="Timer.html">
<link title="Timing_wheel" rel="Chapter" href="Timing_wheel.html">
<link title="Timing_wheel_intf" rel="Chapter" href="Timing_wheel_intf.html">
<link title="Timing_wheel_unit_tests" rel="Chapter" href="Timing_wheel_unit_tests.html">
<link title="Tuple" rel="Chapter" href="Tuple.html">
<link title="Type_equal" rel="Chapter" href="Type_equal.html">
<link title="Union_find" rel="Chapter" href="Union_find.html">
<link title="Unique_id" rel="Chapter" href="Unique_id.html">
<link title="Unique_id_intf" rel="Chapter" href="Unique_id_intf.html">
<link title="Unit" rel="Chapter" href="Unit.html">
<link title="Univ" rel="Chapter" href="Univ.html">
<link title="Univ_map" rel="Chapter" href="Univ_map.html">
<link title="Unpack_buffer" rel="Chapter" href="Unpack_buffer.html">
<link title="User_and_group" rel="Chapter" href="User_and_group.html">
<link title="Uuid" rel="Chapter" href="Uuid.html">
<link title="Validate" rel="Chapter" href="Validate.html">
<link title="With_return" rel="Chapter" href="With_return.html">
<link title="Word_size" rel="Chapter" href="Word_size.html">
<link title="Zone" rel="Chapter" href="Zone.html"><title>Timing_wheel_intf.S</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Timing_wheel_intf.html" title="Timing_wheel_intf">Up</a>
&nbsp;<a class="post" href="Timing_wheel_intf.Timing_wheel.html" title="Timing_wheel_intf.Timing_wheel">Next</a>
</div>
<h1>Module type <a href="type_Timing_wheel_intf.S.html">Timing_wheel_intf.S</a></h1>
<pre><span class="keyword">module type</span> S = <code class="code">sig</code> <a href="Timing_wheel_intf.S.html">..</a> <code class="code">end</code></pre><hr width="100%">
<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> </pre>

<pre><span id="TYPEtiming_wheel"><span class="keyword">type</span> <code class="type">'a</code> timing_wheel</span> = <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a></code> </pre>

<pre><span class="keyword">module</span> <a href="Timing_wheel_intf.S.Alarm.html">Alarm</a>: <code class="code">sig</code> <a href="Timing_wheel_intf.S.Alarm.html">..</a> <code class="code">end</code></pre><pre><span class="keyword">include</span> Invariant.S1</pre>
<pre><span class="keyword">module</span> <a href="Timing_wheel_intf.S.Level_bits.html">Level_bits</a>: <code class="code">sig</code> <a href="Timing_wheel_intf.S.Level_bits.html">..</a> <code class="code">end</code></pre><pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?level_bits:<a href="Timing_wheel_intf.S.Level_bits.html#TYPEt">Level_bits.t</a> -><br>       start:Timing_wheel_intf.Time.t -><br>       alarm_precision:Timing_wheel_intf.Time.Span.t -><br>       dummy:'a -> unit -> 'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a></code></pre><div class="info">
<code class="code">create ~start ~alarm_precision ~dummy ()</code> creates a new timing wheel with current
      time <code class="code">start</code>.  The <code class="code">dummy</code> value is a performance optimization; it would be a bug if
      the timing wheel ever returned the <code class="code">dummy</code> value to client code.
<p>

      For a fixed <code class="code">level_bits</code>, a smaller (i.e. more precise) <code class="code">alarm_precision</code> decreases
      the representable range of times/keys and increases the constant factor for
      <code class="code">advance_clock</code>.
<p>

      <code class="code">create</code> raises if <code class="code">alarm_precision &lt;= 0</code>.<br>
</div>
<pre><span id="VALalarm_precision"><span class="keyword">val</span> alarm_precision</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> Timing_wheel_intf.Time.Span.t</code></pre><div class="info">
Accessors<br>
</div>
<pre><span id="VALnow"><span class="keyword">val</span> now</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> Timing_wheel_intf.Time.t</code></pre><pre><span id="VALstart"><span class="keyword">val</span> start</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> Timing_wheel_intf.Time.t</code></pre><pre><span id="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> bool</code></pre><div class="info">
One can think of a timing wheel as a set of alarms.  Here are various container
      functions along those lines.<br>
</div>
<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> int</code></pre><pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -><br>       f:('a <a href="Timing_wheel_intf.S.Alarm.html#TYPEt">Alarm.t</a> -> unit) -> unit</code></pre><pre><span id="VALinterval_start"><span class="keyword">val</span> interval_start</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -><br>       Timing_wheel_intf.Time.t -> Timing_wheel_intf.Time.t</code></pre><div class="info">
<code class="code">interval_start t time</code> returns the time at the start of the half-open interval
      containing <code class="code">time</code>, i.e. the largest time less than or equal to <code class="code">time</code> that is of the
      form <code class="code">start t + k * alarm_precision t</code>.  <code class="code">interval_start</code> raises if <code class="code">time &lt; start t</code>
      or <code class="code">time</code> is too far in the future to represent.<br>
</div>
<pre><span id="VALadvance_clock"><span class="keyword">val</span> advance_clock</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -><br>       to_:Timing_wheel_intf.Time.t -><br>       handle_fired:('a <a href="Timing_wheel_intf.S.Alarm.html#TYPEt">Alarm.t</a> -> unit) -> unit</code></pre><div class="info">
<code class="code">advance_clock t ~to_ ~handle_fired</code> advances <code class="code">t</code>'s clock to <code class="code">to_</code>.  It fires and
      removes all alarms <code class="code">a</code> in <code class="code">t</code> with <code class="code">Time.(&lt;) (Alarm.at a) (interval_start t to_)</code>
      applying <code class="code">handle_fired</code> to each such <code class="code">a</code>.
<p>

      If <code class="code">to_ &lt;= now t</code>, then <code class="code">advance_clock</code> does nothing.
<p>

      <code class="code">advance_clock</code> fails if <code class="code">to_</code> is too far in the future to represent.
<p>

      Behavior is unspecified if <code class="code">handle_fired</code> accesses <code class="code">t</code> in any way other than
      <code class="code">Alarm</code> functions.<br>
</div>
<pre><span id="VALalarm_upper_bound"><span class="keyword">val</span> alarm_upper_bound</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> Timing_wheel_intf.Time.t</code></pre><div class="info">
<code class="code">alarm_upper_bound t</code> returns the upper bound on an <code class="code">at</code> that can be supplied to
      <code class="code">add</code>.  <code class="code">alarm_upper_bound t</code> is not constant; its value increases as <code class="code">now t</code>
      increases.<br>
</div>
<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -><br>       at:Timing_wheel_intf.Time.t -> 'a -> 'a <a href="Timing_wheel_intf.S.Alarm.html#TYPEt">Alarm.t</a></code></pre><div class="info">
<code class="code">add t ~at a</code> adds a new value <code class="code">a</code> to <code class="code">t</code> and returns an alarm that can later be
      supplied to <code class="code">remove</code> the alarm from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">at &lt; now t || at &gt;=
      alarm_upper_bound t</code>.<br>
</div>
<pre><span id="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> 'a <a href="Timing_wheel_intf.S.Alarm.html#TYPEt">Alarm.t</a> -> unit</code></pre><div class="info">
<code class="code">remove t alarm</code> removes <code class="code">alarm</code> from <code class="code">t</code>.  It is an error to <code class="code">remove</code> an alarm
      that is not in <code class="code">t</code>.<br>
</div>
<pre><span id="VALnext_alarm_fires_at"><span class="keyword">val</span> next_alarm_fires_at</span> : <code class="type">'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> Timing_wheel_intf.Time.t option</code></pre><div class="info">
<code class="code">next_alarm_fires_at t</code> returns the minimum time to which the clock can be advanced
      such that an alarm will fire, or <code class="code">None</code> if <code class="code">t</code> has no alarms.  If
      <code class="code">next_alarm_fires_at t = Some next</code>, then for the minimum alarm time <code class="code">min</code> that
      occurs in <code class="code">t</code>, it is guaranteed that: <code class="code">next - alarm_precision t &lt;= min &lt; next</code>.<br>
</div>
<pre><span class="keyword">module</span> <a href="Timing_wheel_intf.S.Priority_queue.html">Priority_queue</a>: <code class="code">sig</code> <a href="Timing_wheel_intf.S.Priority_queue.html">..</a> <code class="code">end</code></pre><div class="info">
At the heart of a timing wheel is a priority queue in which the keys are
      non-negative integers corresponding to the intervals of time.
</div>
<pre><span id="VALsexp_of_t"><span class="keyword">val</span> sexp_of_t</span> : <code class="type">('a -> <a href="../sexplib/Sexp.html">Sexplib.Sexp</a>.t) -> 'a <a href="Timing_wheel_intf.S.html#TYPEt">t</a> -> <a href="../sexplib/Sexp.html">Sexplib.Sexp</a>.t</code></pre><br>
In all <code class="code">Alarm</code> functions, one must supply the timing wheel that the alarm was
        <code class="code">add</code>ed to.  It is an error to supply a different timing wheel.<br>
<br>
The timing-wheel implementation uses an array of "levels", where level <code class="code">i</code> is an
        array of length <code class="code">2^b_i</code>, where the <code class="code">b_i</code> are the "level bits" specified via
        <code class="code">Level_bits.create_exn [b_0, b_1; ...]</code>.
<p>

        A timing wheel can handle approximately <code class="code">2 ** num_bits t</code> intervals/keys beyond
        the current minimum time/key, where <code class="code">num_bits t = b_0 + b_1 + ...</code>.
<p>

        One can use a <code class="code">Level_bits.t</code> to trade off run time and space usage of a timing
        wheel.  For a fixed <code class="code">num_bits</code>, as the number of levels increases, the length of
        the levels decreases and the timing wheel uses less space, but the constant factor
        for the running time of <code class="code">add</code> and <code class="code">increase_min_allowed_key</code> increases.<br>
<br>
In <code class="code">create_exn bits</code>, it is an error if any of the <code class="code">b_i</code> in <code class="code">bits</code> has <code class="code">b_i &lt;= 0</code>,
        or if the sum of the <code class="code">b_i</code> in <code class="code">bits</code> is greater than <code class="code">max_num_bits</code>.<br>
<br>
<code class="code">default</code> returns the default value of <code class="code">level_bits</code> used by <code class="code">Timing_wheel.create</code>
        and <code class="code">Timing_wheel.Priority_queue.create</code>.  It varies based on the machine's word
        size.  Here are the the values and the amount of space used for the level arrays.
<p>

        | word | bits used | level_bits               | space used  |
        |------+-----------+--------------------------+-------------|
        |   32 |        29 | <code class="code">10; 10; 9</code>              | &lt; 4k words  |
        |   64 |        61 | <code class="code">11; 10; 10; 10; 10; 10</code> | &lt; 10k words |<br>
<br>
<code class="code">num_bits t</code> is the sum of the <code class="code">b_i</code> in <code class="code">t</code>.<br>
<br>
<code class="code">durations t ~alarm_precision</code> returns the durations of the levels in <code class="code">t</code>,
        assuming that each interval has duration <code class="code">alarm_precision</code>.<br>
<br>
<code class="code">create ~start ~alarm_precision ~dummy ()</code> creates a new timing wheel with current
      time <code class="code">start</code>.  The <code class="code">dummy</code> value is a performance optimization; it would be a bug if
      the timing wheel ever returned the <code class="code">dummy</code> value to client code.
<p>

      For a fixed <code class="code">level_bits</code>, a smaller (i.e. more precise) <code class="code">alarm_precision</code> decreases
      the representable range of times/keys and increases the constant factor for
      <code class="code">advance_clock</code>.
<p>

      <code class="code">create</code> raises if <code class="code">alarm_precision &lt;= 0</code>.<br>
<br>
Accessors<br>
<br>
One can think of a timing wheel as a set of alarms.  Here are various container
      functions along those lines.<br>
<br>
<code class="code">interval_start t time</code> returns the time at the start of the half-open interval
      containing <code class="code">time</code>, i.e. the largest time less than or equal to <code class="code">time</code> that is of the
      form <code class="code">start t + k * alarm_precision t</code>.  <code class="code">interval_start</code> raises if <code class="code">time &lt; start t</code>
      or <code class="code">time</code> is too far in the future to represent.<br>
<br>
<code class="code">advance_clock t ~to_ ~handle_fired</code> advances <code class="code">t</code>'s clock to <code class="code">to_</code>.  It fires and
      removes all alarms <code class="code">a</code> in <code class="code">t</code> with <code class="code">Time.(&lt;) (Alarm.at a) (interval_start t to_)</code>
      applying <code class="code">handle_fired</code> to each such <code class="code">a</code>.
<p>

      If <code class="code">to_ &lt;= now t</code>, then <code class="code">advance_clock</code> does nothing.
<p>

      <code class="code">advance_clock</code> fails if <code class="code">to_</code> is too far in the future to represent.
<p>

      Behavior is unspecified if <code class="code">handle_fired</code> accesses <code class="code">t</code> in any way other than
      <code class="code">Alarm</code> functions.<br>
<br>
<code class="code">alarm_upper_bound t</code> returns the upper bound on an <code class="code">at</code> that can be supplied to
      <code class="code">add</code>.  <code class="code">alarm_upper_bound t</code> is not constant; its value increases as <code class="code">now t</code>
      increases.<br>
<br>
<code class="code">add t ~at a</code> adds a new value <code class="code">a</code> to <code class="code">t</code> and returns an alarm that can later be
      supplied to <code class="code">remove</code> the alarm from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">at &lt; now t || at &gt;=
      alarm_upper_bound t</code>.<br>
<br>
<code class="code">remove t alarm</code> removes <code class="code">alarm</code> from <code class="code">t</code>.  It is an error to <code class="code">remove</code> an alarm
      that is not in <code class="code">t</code>.<br>
<br>
<code class="code">next_alarm_fires_at t</code> returns the minimum time to which the clock can be advanced
      such that an alarm will fire, or <code class="code">None</code> if <code class="code">t</code> has no alarms.  If
      <code class="code">next_alarm_fires_at t = Some next</code>, then for the minimum alarm time <code class="code">min</code> that
      occurs in <code class="code">t</code>, it is guaranteed that: <code class="code">next - alarm_precision t &lt;= min &lt; next</code>.<br>
<br>
At the heart of a timing wheel is a priority queue in which the keys are
      non-negative integers corresponding to the intervals of time.  The priority queue is
      unlike a typical priority queue in that rather than having a "delete min" operation,
      it has a nondecreasing minimum allowed key, which corresponds to the current time,
      and an <code class="code">increase_min_allowed_key</code> operation, which implements <code class="code">advance_clock</code>.
      <code class="code">increase_min_allowed_key</code> as a side effect removes all elements from the timing
      wheel whose key is smaller than the new minimum, which implements firing the alarms
      whose time has expired.
<p>

      Adding elements to and removing elements from a timing wheel takes constant time,
      unlike a heap-based priority queue which takes log(N), where N is the number of
      elements in the heap.  <code class="code">increase_min_allowed_key</code> takes time proportional to the
      amount of increase in the min-allowed key, as compared to log(N) for a heap.  It is
      these performance differences that motivate the existence of timing wheels and make
      them a good choice for maintaing a set of alarms.  With a timing wheel, one can
      support any number of alarms paying constant overhead per alarm, while paying a
      small constant overhead per unit of time passed.
<p>

      As the minimum allowed key increases, the timing wheel does a lazy radix sort of the
      element keys, with level 0 handling the least significant <code class="code">b_0</code> bits in a key, and
      each subsequent level <code class="code">i</code> handling the next most significant <code class="code">b_i</code> bits.  The levels
      hold increasingly larger ranges of keys, where the union of all the levels can hold
      any key from <code class="code">min_allowed_key t</code> to <code class="code">max_allowed_key t</code>.  When a key is added to the
      timing wheel, it is added at the lowest possible level that can store the key.  As
      the minimum allowed key increases, timing-wheel elements move down levels until they
      reach level 0, and then are eventually removed.<br>
<br>
An <code class="code">Elt.t</code> represents an element that was added to a timing wheel.<br>
<br>
<code class="code">create ?level_bits ~dummy ()</code> creates a new empty timing wheel, <code class="code">t</code>, with <code class="code">length
        t = 0</code> and <code class="code">min_allowed_key t = 0</code>.
<p>

        <code class="code">dummy</code> is a dummy value that will never be returned by any operation, but that
        allows the implementation to be more efficient.<br>
<br>
<code class="code">length t</code> returns the number of elements in the timing wheel.<br>
<br>
<code class="code">is_empty t</code> is <code class="code">length t = 0</code><br>
<br>
To avoid issues with arithmetic overflow, the implementation restricts keys to
        being between <code class="code">0</code> and <code class="code">max_representable_key</code>, where:
<p>

        <pre class="codepre"><code class="code">          max_representable_key = 1 lsl Level_bits.max_num_bits - 1
        </code></pre>
<p>

        This is different from <code class="code">max_allowed_key t</code>, which gives the maximum key that can
        currently be stored in <code class="code">t</code>.  The maximum allowed key is never larger than the
        maximum representable key, but may be smaller.<br>
<br>
<code class="code">min_allowed_key t</code> is the minimum key that can be stored in <code class="code">t</code>.  This only
        indicates the possibility; there need not be an element <code class="code">elt</code> in <code class="code">t</code> with <code class="code">Elt.key
        elt = min_allowed_key t</code>.  This is not the same as the "min_key" operation in a
        typical priority queue.
<p>

        <code class="code">min_allowed_key t</code> can increase over time, via calls to
        <code class="code">increase_min_allowed_key</code>.  It is guaranteed that <code class="code">min_allowed_key t &lt;=
        max_representable_key</code>.<br>
<br>
<code class="code">max_allowed_key t</code> is the maximum allowed key that can be stored in <code class="code">t</code>.  As
        <code class="code">min_allowed_key</code> increases, so does <code class="code">max_allowed_key</code>; however it is not the case
        that <code class="code">max_allowed_key t - min_allowed_key t</code> is a constant.  It is guaranteed that
        <code class="code">max_allowed_key t &gt;= min (max_representable_key, min_allowed_key t + 2^B - 1</code>,
        where <code class="code">B</code> is the sum of the b_i in <code class="code">level_bits</code>.  It is also guaranteed that
        <code class="code">max_allowed_key t &lt;= max_representable_key</code>.<br>
<br>
<code class="code">min_elt t</code> returns an element in <code class="code">t</code> that has the minimum key, if <code class="code">t</code> is
        nonempty.  <code class="code">min_elt</code> takes time proportional to the size of the timing-wheel data
        structure in the worst case.  It is implemented via a linear search.
<p>

        <code class="code">min_key t</code> returns the key of <code class="code">min_elt t</code>, if any.<br>
<br>
<code class="code">add t ~key value</code> adds a new value to <code class="code">t</code> and returns an element that can later
        be supplied to <code class="code">remove</code> the element from <code class="code">t</code>.  <code class="code">add</code> raises if <code class="code">key &lt;
        min_allowed_key t || key &gt; max_allowed_key t</code>.<br>
<br>
<code class="code">remove t elt</code> removes <code class="code">elt</code> from <code class="code">t</code>.  It is an error if <code class="code">elt</code> is not currently
        in <code class="code">t</code>, and this error may or may not be detected.<br>
<br>
<code class="code">increase_min_allowed_key t ~key ~handle_removed</code> increases the minimum allowed
        key in <code class="code">t</code> to <code class="code">key</code>, and removes all elements with keys less than <code class="code">key</code>, applying
        <code class="code">handle_removed</code> to each element that is removed.  If <code class="code">key &lt;= min_allowed_key t</code>,
        then <code class="code">increase_min_allowed_key</code> does nothing.  Otherwise, if
        <code class="code">increase_min_allowed_key</code> returns successfully, <code class="code">min_allowed_key t = key</code>.
<p>

        <code class="code">increase_min_allowed_key</code> raises if <code class="code">key &gt; max_representable_key</code>.
<p>

        <code class="code">increase_min_allowed_key</code> takes time proportional to <code class="code">key - min_allowed_key t</code>,
        although possibly less time.
<p>

        Behavior is unspecified if <code class="code">handle_removed</code> accesses <code class="code">t</code> in any way other than
        <code class="code">Elt</code> functions.<br>
</body></html>
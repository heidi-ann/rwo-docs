<pre><span id="TYPEt"><span class="keyword">type</span> t </span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> invariant : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; unit</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> create : <code class="type">unit -&gt; <a href="Nano_mutex.html#TYPEt">t</a></code></span></pre>
      <div class="info"><code class="code">create ()</code> returns a new, unlocked mutex.</div>
    
 
      <pre><span><span class="keyword">val</span> equal : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; <a href="Nano_mutex.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      <div class="info"><code class="code">equal</code> is <code class="code">phys_equal</code> </div>
    
 
      <pre><span><span class="keyword">val</span> current_thread_has_lock : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; bool</code></span></pre>
      <div class="info"><code class="code">current_thread_has_lock t</code> returns <code class="code">true</code> iff the current thread has <code class="code">t</code> locked.</div>
    
 
      <pre><span><span class="keyword">val</span> lock : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; unit <a href="../core_kernel/Std.Or_error.html#TYPEt">Core_kernel.Std.Or_error.t</a></code></span></pre>
      <div class="info"><code class="code">lock t</code> locks the mutex <code class="code">t</code>, blocking until it can be locked.  <code class="code">lock</code> immediately
    returns <code class="code">Error</code> if the current thread already holds <code class="code">t</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> lock_exn : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; unit</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> try_lock : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; [ `Acquired | `Not_acquired ] <a href="../core_kernel/Std.Or_error.html#TYPEt">Core_kernel.Std.Or_error.t</a></code></span></pre>
      <div class="info"><code class="code">try_lock t</code> locks <code class="code">t</code> if it can immediately do so.  The result indicates whether
    <code class="code">try_lock</code> succeeded in acquiring the lock.  <code class="code">try_lock</code> returns <code class="code">Error</code> if the current
    thread already holds <code class="code">t</code>.</div>
    
 
      <pre><span><span class="keyword">val</span> try_lock_exn : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; [ `Acquired | `Not_acquired ]</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> unlock : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; unit <a href="../core_kernel/Std.Or_error.html#TYPEt">Core_kernel.Std.Or_error.t</a></code></span></pre>
      <div class="info"><code class="code">unlock t</code> unlocks <code class="code">t</code>, if the current thread holds it.  <code class="code">unlock</code> returns <code class="code">Error</code> if
    the lock is not held by the calling thread.</div>
    
 
      <pre><span><span class="keyword">val</span> unlock_exn : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; unit</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> critical_section : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; f:(unit -&gt; 'a) -&gt; 'a</code></span></pre>
      
    
 
      <pre><span><span class="keyword">val</span> sexp_of_t : <code class="type"><a href="Nano_mutex.html#TYPEt">t</a> -&gt; <a href="../sexplib/Sexp.html#TYPEt">Sexplib.Sexp.t</a></code></span></pre>
      
    
<br/><code class="code">create ()</code> returns a new, unlocked mutex.<br/>
	  
<br/><code class="code">equal</code> is <code class="code">phys_equal</code> <br/>
	  
<br/><code class="code">current_thread_has_lock t</code> returns <code class="code">true</code> iff the current thread has <code class="code">t</code> locked.<br/>
	  
<br/><code class="code">lock t</code> locks the mutex <code class="code">t</code>, blocking until it can be locked.  <code class="code">lock</code> immediately
    returns <code class="code">Error</code> if the current thread already holds <code class="code">t</code>.<br/>
	  
<br/><code class="code">try_lock t</code> locks <code class="code">t</code> if it can immediately do so.  The result indicates whether
    <code class="code">try_lock</code> succeeded in acquiring the lock.  <code class="code">try_lock</code> returns <code class="code">Error</code> if the current
    thread already holds <code class="code">t</code>.<br/>
	  
<br/><code class="code">unlock t</code> unlocks <code class="code">t</code>, if the current thread holds it.  <code class="code">unlock</code> returns <code class="code">Error</code> if
    the lock is not held by the calling thread.<br/>
	  

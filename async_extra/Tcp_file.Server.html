<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Tcp_file.Client.html">
<link rel="Up" href="Tcp_file.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Command" rel="Chapter" href="Command.html">
<link title="File_tail" rel="Chapter" href="File_tail.html">
<link title="File_writer" rel="Chapter" href="File_writer.html">
<link title="Import" rel="Chapter" href="Import.html">
<link title="Lock_file" rel="Chapter" href="Lock_file.html">
<link title="Log" rel="Chapter" href="Log.html">
<link title="Persistent_singleton" rel="Chapter" href="Persistent_singleton.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_intf" rel="Chapter" href="Rpc_intf.html">
<link title="Sequencer_table" rel="Chapter" href="Sequencer_table.html">
<link title="Std" rel="Chapter" href="Std.html">
<link title="Tcp" rel="Chapter" href="Tcp.html">
<link title="Tcp_file" rel="Chapter" href="Tcp_file.html">
<link title="Typed_tcp" rel="Chapter" href="Typed_tcp.html">
<link title="Typed_tcp_intf" rel="Chapter" href="Typed_tcp_intf.html">
<link title="Unpack_sequence" rel="Chapter" href="Unpack_sequence.html">
<link title="User_and_group" rel="Chapter" href="User_and_group.html">
<link title="Versioned_rpc" rel="Chapter" href="Versioned_rpc.html">
<link title="Versioned_typed_tcp" rel="Chapter" href="Versioned_typed_tcp.html">
<link title="Weak_hashtbl" rel="Chapter" href="Weak_hashtbl.html"><title>Tcp_file.Server</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Tcp_file.html" title="Tcp_file">Up</a>
&nbsp;<a class="post" href="Tcp_file.Client.html" title="Tcp_file.Client">Next</a>
</div>
<h1>Module <a href="type_Tcp_file.Server.html">Tcp_file.Server</a></h1>
<pre><span class="keyword">module</span> Server: <code class="code">sig</code> <a href="Tcp_file.Server.html">..</a> <code class="code">end</code></pre><hr width="100%">
<pre><span class="keyword">module</span> <a href="Tcp_file.Server.File.html">File</a>: <code class="code">sig</code> <a href="Tcp_file.Server.File.html">..</a> <code class="code">end</code></pre><pre><span id="VALserve"><span class="keyword">val</span> serve</span> : <code class="type">auth:(Import.Socket.Address.Inet.t -> bool) -><br>       port:int -> <a href="Tcp.Server.html#TYPEinet">Tcp.Server.inet</a> Import.Deferred.t</code></pre><div class="info">
<code class="code">serve ~port ()</code> must be called before clients will be able to connect.  Sets up a
      bound tcp socket on port that will be used to serve files to clients.  The unit
      Deferred will be filled when the server is ready to receive clients.
<p>

      The <code class="code">auth</code> function will be called once for every client connection.  If it returns
      false the client will be disconnected immediately.  Further details of <code class="code">auth</code> can be
      found in the documentation for <code class="code">Rpc.serve</code>.<br>
</div>
<pre><span id="VALopen_file"><span class="keyword">val</span> open_file</span> : <code class="type">?append:bool -><br>       ?dos_format:bool -> string -> <a href="Tcp_file.Server.File.html#TYPEt">File.t</a> Import.Deferred.t</code></pre><div class="info">
<code class="code">open_file filename</code> open a file for writing.  The filename given should
      be a real path on the server, and will create a real file there<br>
</div>
<pre><span id="VALserve_existing_static_file"><span class="keyword">val</span> serve_existing_static_file</span> : <code class="type">string -> unit Import.Deferred.t</code></pre><div class="info">
<code class="code">serve_existing_static_file filename</code> adds <code class="code">filename</code> to the list of files
      that can be accessed via the Client module.  As indicated in the name,
      this file must already exist and must not grow or change.  When a client
      requests the file it will be served from beginning to end.<br>
</div>
<pre><span id="VALstop_serving"><span class="keyword">val</span> stop_serving</span> : <code class="type"><a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -> unit</code></pre><div class="info">
<code class="code">stop_serving t</code> stops serving the file t to clients.  Calling this
      function will not close the file if it is open.  (A possible use of this
      function is if you want to delete the file on the sending side.)<br>
</div>
<pre><span id="VALclose"><span class="keyword">val</span> close</span> : <code class="type">?stop_serving:bool -> <a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -> unit Import.Deferred.t</code></pre><div class="info">
<code class="code">close t</code> closes the file t for writing.  If <code class="code">stop_serving</code> is false
      (default is true) the file will be left on disk and will still be served
      to clients on a create request.<br>
</div>
<pre><span id="VALwrite_message"><span class="keyword">val</span> write_message</span> : <code class="type"><a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -> string -> unit</code></pre><div class="info">
<code class="code">write_message t msg</code> write <code class="code">msg</code> to <code class="code">t</code>.  <code class="code">msg</code> is assumed to contain no
      newlines except possibly at the end.  A newline will be added to the end
      in the file if it is not present.  The message may be transmitted to
      clients with or without a newline.  The string passed to write_message is copied
      and so may be freely modified once write_message returns.<br>
</div>
<pre><span id="VALschedule_message"><span class="keyword">val</span> schedule_message</span> : <code class="type"><a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -> <a href="../core/Bigstring.html">Core.Std.Bigstring</a>.t -> unit</code></pre><div class="info">
<code class="code">schedule_message t msg</code> is write, but the message is taken from the
      provided bigstring.  Once a bigstring has been given to this function it is a
      mistake to ever modify the bigstring in the future.  This is because it will take an
      unknown amount of time to deliver the message to all connected clients<br>
</div>
<pre><span id="VALwrite_sexp"><span class="keyword">val</span> write_sexp</span> : <code class="type"><a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -> Core.Std.Sexp.t -> unit</code></pre><div class="info">
<code class="code">write_sexp t sexp</code> writes a Sexp.t as a single message<br>
</div>
<pre><span id="VALflushed"><span class="keyword">val</span> flushed</span> : <code class="type"><a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -> unit Import.Deferred.t</code></pre><div class="info">
<code class="code">flushed t</code> becomes determined only once all messages written to <code class="code">t</code> have been
      written to disk.<br>
</div>
<pre><span id="VALwith_file"><span class="keyword">val</span> with_file</span> : <code class="type">?append:bool -><br>       string -><br>       f:(<a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -> 'a Import.Deferred.t) -> 'a Import.Deferred.t</code></pre><div class="info">
<code class="code">with_file filename ~f</code> opens filename and runs <code class="code">f</code>, passing the resultant
      <code class="code">t</code>.  When the deferred returned by <code class="code">f</code> is determined, <code class="code">t</code> will be
      closed.<br>
</div>
<pre><span id="VALwriter_monitor"><span class="keyword">val</span> writer_monitor</span> : <code class="type"><a href="Tcp_file.Server.File.html#TYPEt">File.t</a> -><br>       (Import.Monitor.t, [ `This_is_a_static_file ]) <a href="../core/Result.html">Core.Std.Result</a>.t</code></pre><div class="info">
<code class="code">monitor t</code> returns a monitor which will listen to errors arising from the
      internal writer used by <code class="code">t</code>.<br>
</div>
<pre><span id="VALdebug_snapshot"><span class="keyword">val</span> debug_snapshot</span> : <code class="type">unit -> Core.Std.Sexp.t</code></pre><div class="info">
<code class="code">debug_snapshot ()</code> returns an s-expression containing details of the current
      state of the Tcp_file server.<br>
</div>
</body></html>
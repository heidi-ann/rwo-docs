<!DOCTYPE HTML>
<html>
<head>

<title>Weak_hashtbl</title>
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type"/>
<link rel="stylesheet" href="style.css" type="text/css"/>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"> </script>
<script type="text/javascript" src="doc_loader.js"> </script>
</head>
<body>

<h1>Module Weak_hashtbl</h1>
<pre><span class="keyword">module</span> Weak_hashtbl</pre><div class="info">A <code class="code">Weak_hashtbl.t</code> is a hashtable that will drop a key and value if the value is no
    longer referenced (by any non-weak pointers).  <code class="code">Weak_hashtbl</code> is in Async rather than
    Core because it relies on finalization in its implementation.  Using non-Async
    finalizers in an async program is wrong (see Async_gc.mli for details), and having
    <code class="code">Weak_hashtbl</code> in Async prevents users from making this mistake.  Unlike (OCaml's)
    <code class="code">Weak.Make</code>, which also describes itself as a &quot;weak hashtable,&quot; <code class="code">Weak_hashtbl</code> gives a
    dictionary style structure.  In fact, OCaml's Weak.Make may better be described as a
    weak set.<br/>    There's a tricky type of bug one can write with this module, e.g.:<br/>    <pre class="codepre"><code class="code">
      type t =
        { foo : string
        ; bar : float Incr.t
        }

      let tbl = Weak_hashtbl.create ()
      let x1 =
        let t = Weak_hashtbl.find_or_add tbl key ~default:(fun () -&gt;
          (... some function that computes a t...))
        in
        t.bar
    </code></pre><br/>    At this point, the value associated with <code class="code">key</code> is unreachable (since all we did with it
    was project out field bar), so it may disappear from the table at any time.</div>
<hr/>
<div file="Weak_hashtbl.html.contents" class="content_to_load"> </div>
</body>
</html>